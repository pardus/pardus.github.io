import {
  derived,
  writable
} from "./chunk-X4SPQ4KJ.js";
import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  __publicField,
  add_location,
  assign,
  binding_callbacks,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  component_subscribe,
  compute_rest_props,
  construct_svelte_component_dev,
  create_component,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  get_store_value,
  globals,
  group_outros,
  init,
  insert_hydration_dev,
  mount_component,
  noop,
  onDestroy,
  onMount,
  outro_and_destroy_block,
  safe_not_equal,
  setContext,
  set_attributes,
  space,
  subscribe,
  transition_in,
  transition_out,
  update_keyed_each,
  update_slot_base,
  validate_each_argument,
  validate_each_keys,
  validate_slots,
  validate_store
} from "./chunk-JNMFEW2A.js";

// node_modules/@roxi/routify/lib/runtime/Route/utils.js
var uriDecodeStringOrArray = (strOrArr) => strOrArr instanceof Array ? strOrArr.map(decodeURI) : decodeURI(strOrArr);
var URIDecodeObject = (obj) => Object.entries(obj).reduce(
  (_return, [key, value]) => ({
    ..._return,
    [key]: uriDecodeStringOrArray(value)
  }),
  {}
);
var LoadCache = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  async fetch(id, options) {
    if (!this.map.has(id))
      this.map.set(id, options.hydrate());
    this._handlePromise(id, options);
    return this.map.get(id);
  }
  async _handlePromise(id, options) {
    var _a;
    const value = await this.map.get(id);
    const clear = (_a = options.clear) == null ? void 0 : _a.call(options, value);
    if (typeof clear === "number")
      setTimeout(() => this.map.delete(id), clear);
    else if (clear)
      this.map.delete(id);
  }
};

// node_modules/@roxi/routify/lib/runtime/Route/RouteFragment.js
var RouteFragment = class {
  constructor(route, node2, urlFragment = "", params2 = {}) {
    __publicField(this, "_params", {});
    this.route = route;
    this.node = node2;
    this.load = void 0;
    this.urlFragment = urlFragment;
    this.params = params2;
    this.renderContext = writable();
    Object.defineProperty(this, "route", { enumerable: false });
  }
  get index() {
    return this.route.fragments.indexOf(this);
  }
  get params() {
    return URIDecodeObject(this._params);
  }
  set params(params2) {
    this._params = params2;
  }
};

// node_modules/@roxi/routify/lib/runtime/Route/Route.js
var URL_STATES = ["pushState", "replaceState", "popState"];
var loadCache = new LoadCache();
var Route = class {
  constructor(router, url2, mode, state = {}) {
    __publicField(this, "allFragments", []);
    __publicField(this, "load", {
      status: 200,
      error: null,
      maxage: null,
      props: {},
      redirect: null
    });
    const [, hash] = url2.match(/#(.+)/) || [];
    this.router = router;
    this.url = url2;
    this.mode = mode;
    this.state = state;
    this.hash = hash;
    this.state.createdAt = new Date();
    if (!router.rootNode) {
      this.router.log.error("Can't navigate without a rootNode");
      const err = new Error("Can't navigate without a rootNode");
      Object.assign(err, { routify: { router } });
      throw err;
    }
    if (!URL_STATES.includes(mode))
      throw new Error("url.mode must be pushState, replaceState or popState");
    this.allFragments = this._createFragments();
    this.log = router.log.createChild("[route]");
    this.log.debug("created", this);
  }
  get fragments() {
    return this.router.transformFragments.run(this.allFragments);
  }
  get params() {
    const match = this.url.match(/\?.+/);
    const query = match && match[0] || "";
    return Object.assign(
      {},
      ...this.allFragments.map((fragment) => fragment.params),
      this.router.queryHandler.parse(query, this)
    );
  }
  get leaf() {
    return [...this.allFragments].pop();
  }
  get isPendingOrPrefetch() {
    return this === this.router.pendingRoute.get() || this.state.prefetch;
  }
  async loadRoute() {
    const pipeline = [
      this.runBeforeUrlChangeHooks,
      this.loadComponents,
      this.runPreloads
    ];
    for (const pretask of pipeline) {
      const passedPreTask = await pretask.bind(this)();
      if (!this.isPendingOrPrefetch || !passedPreTask)
        return false;
    }
    this.log.debug("loaded route", this);
    return true;
  }
  async loadComponents() {
    this.log.debug("load components", this);
    const nodes = this.fragments.map((fragment) => fragment.node);
    const multiNodes = nodes.map((node2) => node2.children.find((node3) => node3.name === "_decorator")).filter(Boolean);
    await Promise.all([...nodes, ...multiNodes].map((node2) => node2.loadModule()));
    return true;
  }
  async runPreloads() {
    var _a;
    this.log.debug("run preloads", this);
    const prevRoute = this.router.activeRoute.get();
    for (const [index, fragment] of this.fragments.entries()) {
      if (!this.isPendingOrPrefetch)
        return false;
      const prevFragmentInSpot = prevRoute == null ? void 0 : prevRoute.fragments[index];
      const isSameBranch = fragment.node === (prevFragmentInSpot == null ? void 0 : prevFragmentInSpot.node);
      const ctx = {
        route: this,
        prevRoute,
        isNew: !isSameBranch,
        fetch
      };
      if ((_a = fragment.node.module) == null ? void 0 : _a.load) {
        const cacheId = JSON.stringify([this.params, fragment.node.id]);
        const load = await loadCache.fetch(cacheId, {
          hydrate: () => fragment.node.module.load(ctx),
          clear: (res) => (res == null ? void 0 : res.expire) || !this.state.prefetch
        });
        fragment.load = {
          ...isSameBranch && prevFragmentInSpot.load,
          ...load
        };
        Object.assign(this.load, fragment.load);
        if (this.load.redirect)
          return this.router.url.replace(this.load.redirect, {
            redirectedBy: this
          });
      }
    }
    return this;
  }
  async runBeforeUrlChangeHooks() {
    return await this.router.beforeUrlChange.run({ route: this });
  }
  get meta() {
    return this.allFragments.reduce(
      (acc, curr) => ({ ...acc, ...curr.node.meta }),
      {}
    );
  }
  createFragment(node2, urlFragment = "", params2 = {}) {
    return new RouteFragment(this, node2, urlFragment, params2);
  }
  _createFragments() {
    const url2 = this.url.replace(/[#?].+/, "");
    const rootNode = this.router.rootNode;
    const nodeChain = this.router.rootNode.getChainTo(url2, {
      rootNode,
      allowDynamic: true,
      includeIndex: true
    });
    const fragments = nodeChain.map(
      (nc) => this.createFragment(nc.node, nc.fragment, nc.params)
    );
    return fragments;
  }
};

// node_modules/consolite/esm/index.mjs
var defaults = {
  filter: "",
  level: 3,
  levels: {
    default: 3,
    error: 1,
    warn: 2,
    debug: 4,
    trace: 4
  }
};
var noop2 = (x) => x;
var unique = (v, i, a) => a.indexOf(v) === i;
var escapeRegExp = (str) => str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
var escapeIfString = (str) => typeof str === "string" ? escapeRegExp(str) : str;
var Consolite = class {
  constructor(...prefix) {
    __publicField(this, "prefix", []);
    __publicField(this, "_filter", null);
    __publicField(this, "_level", null);
    __publicField(this, "_levels", {});
    __publicField(this, "parent", null);
    __publicField(this, "levels", new Proxy(this._levels, {
      ownKeys: (target) => {
        var _a;
        return [
          ...Object.keys(defaults.levels),
          ...Object.keys(((_a = this.parent) == null ? void 0 : _a.levels) || {}),
          ...Reflect.ownKeys(target)
        ].filter(unique);
      },
      getOwnPropertyDescriptor: (target, key) => ({
        value: target[key],
        enumerable: true,
        configurable: true
      }),
      get: (target, prop) => {
        var _a, _b;
        return target[prop] || target.default || ((_a = this.parent) == null ? void 0 : _a.levels[prop]) || ((_b = this.parent) == null ? void 0 : _b.levels.default) || defaults.levels[prop] || defaults.levels.default;
      },
      set: (target, prop, value) => target[prop] = value
    }));
    __publicField(this, "create", createLogger);
    this.prefix.push(...prefix);
    const withinLevel = (prop) => this.levels[prop] <= this.level;
    const passesFilter = () => typeof this.filter === "function" ? this.filter(prefix) : prefix.join("").match(escapeIfString(this.filter));
    this.register = (prop, fn) => Object.defineProperty(this, prop, {
      get: () => {
        const canBind = typeof fn === "function";
        const shouldPrint = withinLevel(prop) && passesFilter() && canBind;
        const prefixes = prefix.map((p) => typeof p === "string" ? p : p(prop, this));
        return shouldPrint ? fn.bind(console, ...prefixes) : noop2;
      }
    });
    Object.keys(console).forEach((prop) => this.register(prop, console[prop]));
  }
  get level() {
    var _a, _b, _c;
    return (_c = (_b = this._level) != null ? _b : (_a = this.parent) == null ? void 0 : _a.level) != null ? _c : defaults.level;
  }
  set level(val) {
    this._level = val;
  }
  get filter() {
    var _a, _b, _c;
    return (_c = (_b = this._filter) != null ? _b : (_a = this.parent) == null ? void 0 : _a.filter) != null ? _c : defaults.filter;
  }
  set filter(val) {
    this._filter = val;
  }
  get root() {
    var _a;
    return ((_a = this.parent) == null ? void 0 : _a.root) || this;
  }
  createChild(...prefix) {
    const child = createLogger(...this.prefix, ...prefix);
    child.parent = this;
    return child;
  }
  createParent(...prefix) {
    return createLogger(...prefix, ...this.prefix);
  }
};
var createLogger = (...prefix) => Object.assign(new Consolite(...prefix));

// node_modules/@roxi/routify/lib/runtime/utils/logger.js
var log = createLogger("[rf3]");
var createRootLogger = () => {
  Object.assign(log, loadState());
  return new Proxy(log, {
    get: (target, prop) => target[prop],
    set: (target, prop, value) => {
      target[prop] = value;
      saveState(log);
      return false;
    }
  });
};
var loadState = () => {
  if (typeof window === "undefined") {
    const level = process.env.DEBUG_LEVEL;
    const filter = process.env.DEBUG_FILTER;
    return { level, filter };
  } else {
    return JSON.parse(localStorage.getItem("__routify.logState") || "{}");
  }
};
var saveState = (log2) => {
  const { level, filter } = log2;
  if (typeof window === "undefined") {
    process.env.DEBUG_LEVEL = level;
    process.env.DEBUG_FILTER = filter;
  } else
    localStorage.setItem("__routify.logState", JSON.stringify({ filter, level }));
};
var debugWrapper = (fn, msg) => (...params2) => {
  const result = fn(...params2);
  log.debug(msg, { params: params2, result });
  return result;
};

// node_modules/@roxi/routify/lib/runtime/Global/BrowserAdapter.js
var createBrowserAdapter = (opts) => {
  const delimiter = (opts == null ? void 0 : opts.delimiter) || ";";
  return {
    toRouter: (url2, router) => {
      const formatRE = router.name ? `${router.name}=(.+?)` : `(.+?)`;
      const RE = new RegExp(`(^|${delimiter})${formatRE}(${delimiter}|$)`);
      const matches = url2.match(RE);
      return matches ? matches[2] : "/";
    },
    toBrowser: (routers) => routers.map((r) => (r.name ? `${r.name}=` : "") + r.url.external()).join(delimiter)
  };
};

// node_modules/@roxi/routify/lib/runtime/Global/Global.js
var AppInstance = class {
  constructor() {
    __publicField(this, "instances", []);
    __publicField(this, "browserAdapter", createBrowserAdapter());
    __publicField(this, "urlFromBrowser", (router) => {
      if (debugWrapper)
        return debugWrapper(
          this.browserAdapter.toRouter,
          "calling browserAdapter.toRouter"
        )(urlFromAddress(), router);
      return this.browserAdapter.toRouter(urlFromAddress(), router);
    });
    globalThis["__routify"] = this;
    this.log = createRootLogger();
  }
  get routers() {
    return [].concat(...this.instances.map((instance8) => instance8.routers));
  }
  register(instance8) {
    this.instances.push(instance8);
    return this;
  }
};
var appInstance = new AppInstance();

// node_modules/@roxi/routify/lib/runtime/utils/index.js
var shouldIgnoreClick = (event) => event.ctrlKey || event.metaKey || event.altKey || event.shiftKey || event.button || event.key && event.key !== "Enter" || event.defaultPrevented;
var getUrlFromEvent = (event) => {
  const el = event.target.closest("a");
  const href = el && el.href;
  if (!href || el.target || el.host !== location.host)
    return;
  const url2 = new URL(href);
  const relativeUrl = url2.pathname + url2.search + url2.hash;
  event.preventDefault();
  return relativeUrl;
};
var pathAndParamsToUrl = (path, params2 = {}, queryHandler, useWildcards) => {
  Object.entries(params2).forEach(([key, val]) => {
    if (path.includes(`[${key}]`)) {
      path = path.replace(`[${key}]`, val);
      delete params2[key];
    }
  });
  if (useWildcards)
    path = insertWildcards(path);
  return path + queryHandler(params2);
};
var insertWildcards = (str) => {
  return str.replace(/\[.*?\]/, ".*?");
};
var fromEntries = (iterable) => {
  return [...iterable].reduce((obj, [key, val]) => {
    obj[key] = val;
    return obj;
  }, {});
};
var populateUrl = (path, params2, route) => {
  const overloads = {};
  Object.entries(params2).forEach(([param, value]) => {
    const RE = new RegExp(`\\[(...)?${param}\\]|\\:${param}`);
    value = Array.isArray(value) ? value.join("/") : value;
    if (path.match(RE))
      path = path.replace(RE, encodeURI(value));
    else
      overloads[param] = value;
  });
  const query = route.router.queryHandler.stringify(overloads, route);
  return path + query;
};
var urlFromAddress = () => (({ pathname, search, hash }) => pathname + search + hash)(window.location);
var getGlobalContext = () => {
  console.log("Using helpers outside router context is not supported. Use at own risk.");
  const router = appInstance.routers[0];
  const route = router.activeRoute.get() || router.pendingRoute.get();
  return {
    elem: null,
    anchorLocation: null,
    options: null,
    childFragments: writable(route.allFragments),
    node: router.rootNode,
    fragment: route.allFragments[0],
    isActive: writable(false),
    isVisible: writable(false),
    inline: null,
    router,
    route,
    parentContext: null,
    onDestroy: null,
    decorators: [],
    single: writable(true),
    scrollBoundary: null
  };
};
var contexts = {
  get router() {
    return (getContext("routify-fragment-context") || getGlobalContext()).router;
  },
  get fragment() {
    return getContext("routify-fragment-context") || getGlobalContext();
  }
};
var getContextMaybe = (name) => {
  try {
    return getContext(name);
  } catch (err) {
  }
};
var getable = (value, start) => {
  const store = writable(value, start);
  return Object.assign(store, { get: () => get_store_value(store) });
};
var identicalRoutes = (...routes) => routes.map((route) => JSON.stringify([route == null ? void 0 : route.allFragments, route == null ? void 0 : route.url])).reduce((prev, curr) => prev === curr && curr);
var isAnonFn = (input) => typeof input === "function" && !input.prototype;
var resolveIfAnonFn = (subject, params2) => isAnonFn(subject) ? subject(...params2) : subject;
var pushToOrReplace = (arr, input) => {
  const _isAnonFn = isAnonFn(input);
  input = _isAnonFn || Array.isArray(input) ? input : [input];
  const res = _isAnonFn ? input([...arr]) : [...arr, ...input];
  if (!Array.isArray(res))
    throw new Error("anonymous callback did not return array");
  return res;
};
var waitFor = (store, cb) => new Promise((resolve, reject) => {
  try {
    const unsub = store.subscribe((val) => {
      if (cb(val)) {
        resolve(val);
        setTimeout(() => unsub);
      }
    });
  } catch (err) {
    reject(err);
  }
});

// node_modules/@roxi/routify/lib/runtime/Router/urlReflectors/ReflectorBase.js
var BaseReflector = class {
  constructor(router) {
    this.router = router;
    this.log = this.router.log;
  }
  install() {
  }
  uninstall() {
  }
  reflect() {
  }
};

// node_modules/@roxi/routify/lib/common/RNode.js
var RNode = class {
  constructor(name, module, instance8) {
    __publicField(this, "parent");
    __publicField(this, "meta", {});
    __publicField(this, "id");
    __publicField(this, "_regex", {});
    __publicField(this, "_paramKeys", {});
    this.instance = instance8;
    this.name = name;
    instance8.nodeIndex.push(this);
    this.module = module;
    Object.defineProperty(this, "instance", { enumerable: false });
    Object.defineProperty(this, "parent", { enumerable: false });
  }
  appendChild(child) {
    if (child.instance)
      child.parent = this;
  }
  createChild(name, module) {
    const node2 = this.instance.createNode(name, module);
    this.appendChild(node2);
    return node2;
  }
  get descendants() {
    return this.instance.nodeIndex.filter(
      (node2) => node2.ancestors.find((n) => n === this)
    );
  }
  remove() {
    const { nodeIndex } = this.instance;
    const index = nodeIndex.findIndex((node2) => node2 === this);
    nodeIndex.splice(index, 1);
  }
  get ancestors() {
    let node2 = this;
    const ancestors = [];
    while (node2 = node2.parent)
      ancestors.push(node2);
    return ancestors;
  }
  get root() {
    let node2 = this;
    while (node2.parent)
      node2 = node2.parent;
    return node2;
  }
  get isRoot() {
    return this === this.root;
  }
  get children() {
    return this.instance.nodeIndex.filter((node2) => node2.parent === this);
  }
  get level() {
    var _a;
    return (((_a = this.parent) == null ? void 0 : _a.level) || 0) + 1;
  }
  get regex() {
    const { name } = this;
    if (!this._regex[name])
      this._regex[name] = this.instance.utils.getRegexFromName(this.name);
    return this._regex[name];
  }
  set regex(value) {
    this._regex[this.name] = new RegExp(value);
  }
  get paramKeys() {
    const { name } = this;
    if (!this._paramKeys[name])
      this._paramKeys[name] = this.instance.utils.getFieldsFromName(this.name);
    return this._paramKeys[name];
  }
  getParams(urlFragment) {
    if (urlFragment.match(/^\.+$/))
      return {};
    const values = this.instance.utils.getValuesFromPath(this.regex, urlFragment);
    return this.instance.utils.mapFieldsWithValues(this.paramKeys, values);
  }
  traverse(path, allowDynamic = false, includeIndex = false, silent = false) {
    var _a;
    const isNamed = !path.startsWith("/") && !path.startsWith(".");
    return isNamed ? this.root.instance.nodeIndex.find((node2) => node2.meta.name === path) : (_a = this.getChainTo(path, { allowDynamic, includeIndex, silent })) == null ? void 0 : _a.pop().node;
  }
  getChainTo(path, options) {
    options = {
      ...{ allowDynamic: true, includeIndex: true },
      ...options
    };
    const originNode = path.startsWith("/") ? options.rootNode || this.root : this;
    const stepsToLeaf = path.split("/").filter((snip) => snip !== ".").filter(Boolean);
    let currentNodeStep = {
      node: originNode,
      stepsToLeaf,
      params: {},
      fragment: ""
    };
    const nodeSteps = [currentNodeStep];
    let inStaticDeadEnd = false;
    let inDynamicDeadEnd = false;
    while (currentNodeStep.stepsToLeaf.length) {
      const [nextStep, ...restSteps] = currentNodeStep.stepsToLeaf;
      const nextNode = nextStep === ".." ? currentNodeStep.node.parent : !inStaticDeadEnd && currentNodeStep.node.children.find(
        (node2) => node2.name === nextStep
      ) || options.allowDynamic && !inDynamicDeadEnd && currentNodeStep.node.children.filter(({ meta: meta2 }) => meta2.dynamic && !meta2.dynamicSpread).find((node2) => node2.regex.test(nextStep)) || options.allowDynamic && currentNodeStep.node.children.find(
        (node2) => node2.meta.dynamicSpread
      );
      if (nextNode) {
        const nodeStep = {
          node: nextNode,
          params: nextNode.meta.dynamicSpread ? [nextStep] : nextNode.meta.dynamic ? nextNode.getParams(nextStep) : {},
          stepsToLeaf: restSteps,
          fragment: nextStep
        };
        currentNodeStep = nodeStep;
        nodeSteps.push(nodeStep);
      } else if (!options.allowDynamic && options.silent)
        return null;
      else if (!options.allowDynamic && !options.silent)
        throw new Error(
          `${nodeSteps.map((ns) => ns.node.name || "root").join("/")} could not travel to ${nextStep}`
        );
      else if (currentNodeStep.node.meta.dynamicSpread) {
        currentNodeStep.params.push(nextStep);
        currentNodeStep.fragment += `/${nextStep}`;
        currentNodeStep.stepsToLeaf.shift();
        inDynamicDeadEnd = false;
        inStaticDeadEnd = false;
      } else {
        nodeSteps.pop();
        currentNodeStep = [...nodeSteps].pop();
        inDynamicDeadEnd = inStaticDeadEnd;
        inStaticDeadEnd = true;
        if (!currentNodeStep && options.silent)
          return null;
        else if (!currentNodeStep && !options.silent)
          throw new Error(`Could not find path "${path}" from ${this.name}`);
      }
    }
    try {
      const indexNode = options.includeIndex && currentNodeStep.node.traverse("./index");
      if (indexNode)
        nodeSteps.push({
          node: indexNode,
          stepsToLeaf: [],
          params: {},
          fragment: ""
        });
    } catch (err) {
    }
    nodeSteps.forEach((ns) => {
      ns.params = Array.isArray(ns.params) ? { [ns.node.name.replace(/\[\.\.\.(.+)\]/, "$1")]: ns.params } : ns.params;
    });
    return nodeSteps;
  }
  toJSON() {
    return {
      ...this,
      children: [...this.children]
    };
  }
  get path() {
    return "/" + [this, ...this.ancestors].reverse().map((node2) => node2.name).filter(Boolean).join("/");
  }
};

// node_modules/@roxi/routify/lib/runtime/Instance/Node.svelte
function create_else_block(ctx) {
  let current;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[5],
            !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(19:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [ctx[0], { context: ctx[2] }];
  var switch_value = ctx[1];
  function switch_props(ctx2) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx: ctx2 }
    };
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const switch_instance_changes = dirty & 5 ? get_spread_update(switch_instance_spread_levels, [
        dirty & 1 && get_spread_object(ctx2[0]),
        dirty & 4 && { context: ctx2[2] }
      ]) : {};
      if (dirty & 32) {
        switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (dirty & 2 && switch_value !== (switch_value = ctx2[1])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(15:0) {#if Component}",
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let current;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[5],
            !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(16:4) <svelte:component this={Component} {...passthrough} {context}>",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[1])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var CTX = "routify-fragment-context";
function instance($$self, $$props, $$invalidate) {
  var _a;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Node", slots, ["default"]);
  let { node: node2 } = $$props;
  let { passthrough } = $$props;
  const context2 = { ...getContext(CTX), node: node2 };
  setContext(CTX, context2);
  let Component = (_a = node2.module) == null ? void 0 : _a.default;
  if (!Component && node2.asyncModule)
    node2.asyncModule().then((r) => $$invalidate(1, Component = r.default));
  $$self.$$.on_mount.push(function() {
    if (node2 === void 0 && !("node" in $$props || $$self.$$.bound[$$self.$$.props["node"]])) {
      console.warn("<Node> was created without expected prop 'node'");
    }
    if (passthrough === void 0 && !("passthrough" in $$props || $$self.$$.bound[$$self.$$.props["passthrough"]])) {
      console.warn("<Node> was created without expected prop 'passthrough'");
    }
  });
  const writable_props = ["node", "passthrough"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Node> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$invalidate(3, node2 = $$props2.node);
    if ("passthrough" in $$props2)
      $$invalidate(0, passthrough = $$props2.passthrough);
    if ("$$scope" in $$props2)
      $$invalidate(5, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    setContext,
    node: node2,
    passthrough,
    CTX,
    context: context2,
    Component
  });
  $$self.$inject_state = ($$props2) => {
    if ("node" in $$props2)
      $$invalidate(3, node2 = $$props2.node);
    if ("passthrough" in $$props2)
      $$invalidate(0, passthrough = $$props2.passthrough);
    if ("Component" in $$props2)
      $$invalidate(1, Component = $$props2.Component);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [passthrough, Component, context2, node2, slots, $$scope];
}
var Node = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { node: 3, passthrough: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Node",
      options,
      id: create_fragment.name
    });
  }
  get node() {
    throw new Error("<Node>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set node(value) {
    throw new Error("<Node>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get passthrough() {
    throw new Error("<Node>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set passthrough(value) {
    throw new Error("<Node>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Node_default = Node;

// node_modules/@roxi/routify/lib/runtime/Instance/RNodeRuntime.js
var RNodeRuntime = class extends RNode {
  constructor(name, module, instance8, asyncModule) {
    super(name, module, instance8);
    __publicField(this, "asyncModule");
    __publicField(this, "importTree", (snapshotRoot) => {
      const queue = [[this, snapshotRoot]];
      while (queue.length) {
        const [node2, snapshot] = queue.pop();
        const { children: children2, ...nodeSnapshot } = snapshot;
        Object.assign(node2, nodeSnapshot);
        for (const childSnapshot of children2) {
          const childNode = node2.createChild(
            snapshot.name || snapshot.rootName || ""
          );
          queue.push([childNode, childSnapshot]);
        }
      }
      return this;
    });
    this.module = module;
    this.asyncModule = asyncModule;
  }
  get children() {
    return this.instance.nodeIndex.filter((node2) => node2.parent === this).sort((prev, curr) => (prev.meta.order || 0) - (curr.meta.order || 0));
  }
  get pages() {
    return this.pagesWithIndex.filter((node2) => node2.name !== "index");
  }
  get pagesWithIndex() {
    return this.children.filter((node2) => !node2.meta.fallback).filter((node2) => !node2.name.startsWith("_")).filter((node2) => !node2.name.includes("[")).filter((node2) => {
      var _a;
      return !(((_a = node2.meta) == null ? void 0 : _a.order) === false);
    });
  }
  get hasComponent() {
    return !!(this.module || this.asyncModule);
  }
  async getRawComponent() {
    const module = await this.loadModule();
    return module == null ? void 0 : module.default;
  }
  async loadModule() {
    if (!this.module && this.asyncModule) {
      this.module = await this.asyncModule();
    }
    return this.module;
  }
  get component() {
    const node2 = this;
    return function(options) {
      options.props = {
        ...options.props,
        passthrough: options.props,
        node: node2
      };
      return new Node_default({ ...options });
    };
  }
  get _fallback() {
    var _a;
    return this.children.find((node2) => node2.meta.fallback) || ((_a = this.parent) == null ? void 0 : _a._fallback);
  }
};

// node_modules/@roxi/routify/lib/runtime/Instance/UrlParamUtils.js
var defaultRe = /\[(.+?)\]/gm;
var UrlParamUtils = class {
  constructor(RE = defaultRe) {
    __publicField(this, "getFieldsFromName", (name) => [...name.matchAll(this.RE)].map((v) => v[1]));
    __publicField(this, "getRegexFromName", (name) => new RegExp("^" + name.replace(this.RE, "(.+)") + "$"));
    __publicField(this, "getValuesFromPath", (re, path) => (path.match(re) || []).slice(1));
    __publicField(this, "mapFieldsWithValues", (fields, values) => this.haveEqualLength(fields, values) && fields.reduce((map, field, index) => {
      map[field] = values[index];
      return map;
    }, {}));
    __publicField(this, "haveEqualLength", (fields, values) => {
      if (fields.length !== values.length)
        throw new Error(
          `fields and values should be of same length
fields: ${JSON.stringify(fields)}
values: ${JSON.stringify(values)}`
        );
      return true;
    });
    this.RE = RE;
  }
};

// node_modules/@roxi/routify/lib/common/Routify.js
var Routify = class {
  constructor() {
    __publicField(this, "NodeConstructor");
    __publicField(this, "NodeType");
    __publicField(this, "nodeIndex", []);
    __publicField(this, "rootNodes", {});
    __publicField(this, "utils", new UrlParamUtils());
  }
  createNode(name, module) {
    return new this.NodeConstructor(name, module, this);
  }
};

// node_modules/@roxi/routify/lib/runtime/Instance/RoutifyRuntime.js
var RoutifyRuntime = class extends Routify {
  constructor(options) {
    super();
    __publicField(this, "NodeConstructor", RNodeRuntime);
    __publicField(this, "mode", "runtime");
    __publicField(this, "routers", []);
    __publicField(this, "rootNodes", {});
    this.options = options;
    if (options.routes) {
      this.rootNodes[options.routes.rootName || "unnamed"] = this.createNode(
        options.routes.rootName
      ).importTree(options.routes);
    }
    this.global = appInstance.register(this);
    Object.defineProperty(this, "routers", { enumerable: false });
    this.log = this.global.log;
  }
};

// node_modules/hookar/esm/util.mjs
var runOnce = (cb) => {
  let hasRun;
  const wrapper = (...params2) => {
    if (hasRun)
      return;
    hasRun = true;
    return cb(...params2);
  };
  return wrapper;
};

// node_modules/hookar/esm/index.mjs
var createHooksCollection = (runner) => {
  const hooks = [];
  const hooksCollection = (hook) => {
    hooks.push(hook);
    return () => hooks.splice(hooks.indexOf(hook), 1);
  };
  hooksCollection.hooks = hooks;
  hooksCollection.run = runner(hooks);
  hooksCollection.runOnce = runOnce(runner(hooks));
  return hooksCollection;
};
var createPipelineCollection = (type) => createHooksCollection(
  (hooks) => (value, ...rest) => hooks.reduce(
    (pipedValue, hook) => (pipedValue == null ? void 0 : pipedValue.then) ? pipedValue.then((r) => hook(r, ...rest)) : hook(pipedValue, ...rest),
    value
  )
);
var createSequenceHooksCollection = (type) => createHooksCollection(
  (hooks) => (value, ...rest) => hooks.reduce(
    (last, hook) => (last == null ? void 0 : last.then) ? last.then((_) => hook(value, ...rest)) : hook(value, ...rest),
    value
  )
);
var createGuardsCollection = (type) => createHooksCollection(
  (hooks) => (value, ...rest) => hooks.reduce(
    (pipedValue, hook) => (pipedValue == null ? void 0 : pipedValue.then) ? pipedValue.then((r) => r && hook(value, ...rest)) : pipedValue && hook(value, ...rest),
    value || true
  )
);

// node_modules/@roxi/routify/lib/runtime/Router/urlReflectors/Address.js
var AddressReflector = class extends BaseReflector {
  constructor(router) {
    super(router);
    __publicField(this, "reflect", () => {
      const { mode } = get_store_value(this.router.activeRoute);
      if (mode === "popState")
        return false;
      const { routers, browserAdapter } = this.router.instance.global;
      const addressRouters = routers.filter(
        (router) => router.urlReflector instanceof this.constructor
      );
      const url2 = browserAdapter.toBrowser(addressRouters);
      this.log.debug("pushing internal url to browser history", {
        mode,
        url: url2,
        currentBrowserUrl: urlFromAddress(),
        currentInternalUrl: this.router.url.internal()
      });
      history[`${mode}Native`]({}, "", url2);
    });
    const { instance: instance8, urlRewrites } = router;
    const { urlFromBrowser, browserAdapter } = instance8.global;
    if (!history["onPushstate"]) {
      this.log.debug("polyfill history hooks");
      polyfillHistory();
    }
    const createStateEventHandler = (method) => {
      return function(data, title, url2) {
        var _a, _b;
        const routerName = (_b = (_a = data == null ? void 0 : data.routify) == null ? void 0 : _a.router) != null ? _b : false;
        if (routerName === false)
          url2 = browserAdapter.toRouter(url2, router);
        else if (routerName !== router.name)
          return false;
        for (const rewrite of urlRewrites)
          url2 = rewrite.toInternal(url2, { router });
        router.url[method](url2);
      };
    };
    this.absorb = () => router.url.replace(urlFromBrowser(router));
    this._pushstateHandler = createStateEventHandler("push");
    this._replacestateHandler = createStateEventHandler("replace");
    this._popstateHandler = () => router.url.pop(urlFromBrowser(router));
  }
  install() {
    this.hooks = [
      history["onPushstate"](this._pushstateHandler),
      history["onReplacestate"](this._replacestateHandler),
      history["onPopstate"](this._popstateHandler)
    ];
    if (!get_store_value(this.router.activeRoute))
      this.absorb();
    else
      this.reflect();
  }
  uninstall() {
    this.hooks.forEach((unreg) => unreg());
    setTimeout(() => this.reflect());
  }
};
function polyfillHistory() {
  const hooks = {
    onPushstate: createSequenceHooksCollection(),
    onReplacestate: createSequenceHooksCollection(),
    onPopstate: createSequenceHooksCollection()
  };
  Object.assign(history, hooks);
  const { pushState, replaceState } = history;
  history["pushStateNative"] = pushState;
  history["replaceStateNative"] = replaceState;
  history.pushState = hooks.onPushstate.run;
  history.replaceState = hooks.onReplacestate.run;
  window.addEventListener("popstate", hooks.onPopstate.run);
  return true;
}

// node_modules/@roxi/routify/lib/runtime/Router/urlReflectors/Internal.js
var InternalReflector = class extends BaseReflector {
  install() {
    this.router.url.replace("/");
  }
};

// node_modules/@roxi/routify/lib/runtime/plugins/reset/index.js
var parseModuleName = (str) => {
  const matches = str.match(/^(.+?)(\+)?$/);
  const [, name, prepend] = matches;
  return { name, prepend };
};
var handlers = {
  boolean(route, bool, fragment) {
    const index = fragment.index;
    return handlers.number(route, index, fragment);
  },
  number(route, num, fragment) {
    const index = fragment.index;
    const start = index - num;
    route.allFragments.splice(start, num);
  },
  string(route, str, fragment) {
    const selfIndex = fragment.index;
    const precedingFragments = route.allFragments.slice(0, selfIndex + 1);
    let nextFragment;
    const { name, prepend } = parseModuleName(str);
    while (precedingFragments.length) {
      nextFragment = precedingFragments.pop();
      const matchingSiblingNode = nextFragment.node.children.find(
        (node2) => node2.meta.moduleName === name
      );
      if (matchingSiblingNode) {
        if (!prepend)
          route.allFragments.splice(0, fragment.index);
        route.allFragments.unshift(route.createFragment(matchingSiblingNode));
        precedingFragments.splice(0);
      }
    }
  }
};
var handleFragment = (route) => (fragment) => {
  const { reset } = fragment.node.meta;
  if (reset)
    handlers[typeof reset](route, reset, fragment);
};
var reset_default = () => {
  return {
    beforeUrlChange: ({ route }) => {
      const fragments = [...route.allFragments];
      fragments.forEach(handleFragment(route));
      return true;
    }
  };
};

// node_modules/@roxi/routify/lib/common/utils.js
var next = (store, wanted, strict) => new Promise((resolve) => {
  let unsub;
  unsub = store.subscribe((value) => {
    if (!unsub)
      return;
    if (typeof wanted === "undefined" || value === wanted || value == wanted && !strict || typeof wanted === "function" && wanted(value)) {
      resolve(value);
      unsub;
    }
  });
});
var createThrottle = () => {
  const map = /* @__PURE__ */ new Map();
  const throttle2 = async (fn) => {
    const fnStr = fn.toString();
    map.set(fnStr, map.get(fnStr) || { isRunning: false, runAgain: false });
    const s = map.get(fnStr);
    if (s.isRunning)
      s.runAgain = true;
    else {
      s.isRunning = true;
      await fn();
      s.isRunning = false;
      if (s.runAgain) {
        s.runAgain = false;
        await throttle2(fn);
      }
    }
  };
  return throttle2;
};
var throttle = createThrottle();

// node_modules/@roxi/routify/lib/runtime/Router/utils/index.js
var normalizeRouterOptions = (options, config) => {
  config = config || {
    name: "",
    beforeRouterInit: [],
    afterRouterInit: [],
    urlRewrite: [],
    beforeUrlChange: [],
    afterUrlChange: [],
    transformFragments: [],
    onDestroy: []
  };
  const { plugins, ...optionsOnly } = options;
  const optionsGroups = [...plugins || [], optionsOnly];
  optionsGroups.forEach((pluginOptions) => {
    var _a;
    (_a = pluginOptions.plugins) == null ? void 0 : _a.forEach((plugin) => normalizeRouterOptions(plugin, config));
    delete pluginOptions.plugins;
    Object.entries(pluginOptions).forEach(([field, value]) => {
      if (Array.isArray(config[field]))
        config[field].push(...[value].flat().filter(Boolean));
      else
        config[field] = value || config[field];
    });
  });
  return config;
};

// node_modules/@roxi/routify/lib/runtime/Router/Router.js
var stripNullFields = (obj) => Object.fromEntries(Object.entries(obj).filter(([_, v]) => v != null));
var defaultPlugins = [reset_default()];
var Router = class {
  constructor(input) {
    __publicField(this, "pendingRoute", getable(null));
    __publicField(this, "activeRoute", getable(null));
    __publicField(this, "_urlReflector", null);
    __publicField(this, "urlRewrites", []);
    __publicField(this, "beforeRouterInit", createSequenceHooksCollection());
    __publicField(this, "afterRouterInit", createSequenceHooksCollection());
    __publicField(this, "beforeUrlChange", createGuardsCollection());
    __publicField(this, "afterUrlChange", createSequenceHooksCollection());
    __publicField(this, "transformFragments", createPipelineCollection());
    __publicField(this, "onDestroy", createSequenceHooksCollection());
    __publicField(this, "parentElem", null);
    __publicField(this, "queryHandler", {
      parse: (search, route) => fromEntries(new URLSearchParams(search)),
      stringify: (params2, route) => {
        const query = new URLSearchParams(params2).toString();
        return query ? `?${query}` : "";
      }
    });
    __publicField(this, "clickHandler", {});
    __publicField(this, "url", {
      internal: () => this.url.getPending() || this.url.getActive(),
      external: () => this.getExternalUrl(),
      getActive: () => {
        var _a;
        return (_a = get_store_value(this.activeRoute)) == null ? void 0 : _a.url;
      },
      getPending: () => {
        var _a;
        return (_a = get_store_value(this.pendingRoute)) == null ? void 0 : _a.url;
      },
      toString: () => this.url.internal(),
      set: this._setUrl.bind(this),
      push: (url2, state = {}) => this._setUrl(url2, "pushState", false, state),
      replace: (url2, state = {}) => this._setUrl(url2, "replaceState", false, state),
      pop: (url2, state = {}) => this._setUrl(url2, "popState", false, state)
    });
    __publicField(this, "ready", async () => !this.pendingRoute.get() && this.activeRoute.get() || next(this.activeRoute, (x) => !!x));
    __publicField(this, "history", []);
    __publicField(this, "setParentElem", (elem) => {
      this.parentElem = elem;
    });
    __publicField(this, "getExternalUrl", (url2) => {
      const result = this.urlRewrites.reduce(
        (_url, rewrite) => rewrite.toExternal(_url, { router: this }),
        url2 || this.url.internal()
      );
      return result;
    });
    __publicField(this, "getInternalUrl", (url2) => this.urlRewrites.reduce(
      (_url, rewrite) => rewrite.toInternal(_url, { router: this }),
      url2
    ));
    const { subscribe: subscribe2, set } = writable(this);
    this.subscribe = subscribe2;
    this.triggerStore = () => set(this);
    const oldRouter = appInstance.routers.find((r) => r.name == (input.name || ""));
    if (oldRouter)
      return oldRouter;
    else {
      input.plugins = [...input.plugins || [], ...defaultPlugins].filter(Boolean);
      this.init(input);
      this.params = derived(this.activeRoute, ($activeRoute) => $activeRoute.params);
      this.afterUrlChange(() => setTimeout(() => this._urlReflector.reflect()));
      this.activeRoute.get = () => get_store_value(this.activeRoute);
      this.pendingRoute.get = () => get_store_value(this.pendingRoute);
    }
  }
  init(input) {
    const firstInit = !this.options;
    input = stripNullFields(input);
    this.options = normalizeRouterOptions({ ...this.options, ...input });
    let {
      instance: instance8,
      rootNode,
      name,
      routes,
      urlRewrite,
      urlReflector,
      url: url2,
      passthrough,
      beforeUrlChange: beforeUrlChange2,
      afterUrlChange: afterUrlChange2,
      transformFragments,
      onDestroy: onDestroy2,
      beforeRouterInit,
      afterRouterInit,
      queryHandler,
      clickHandler
    } = this.options;
    if (queryHandler)
      this.queryHandler = queryHandler;
    if (clickHandler)
      this.clickHandler = clickHandler;
    beforeUrlChange2.forEach(this.beforeUrlChange);
    transformFragments.forEach(this.transformFragments);
    afterUrlChange2.forEach(this.afterUrlChange);
    onDestroy2.forEach(this.onDestroy);
    beforeRouterInit.forEach(this.beforeRouterInit);
    afterRouterInit.forEach(this.afterRouterInit);
    this.beforeRouterInit.run({ router: this, firstInit });
    const parentCmpCtx = getContextMaybe("routify-fragment-context");
    this.instance = instance8 || this.instance || (parentCmpCtx == null ? void 0 : parentCmpCtx.route.router.instance) || appInstance.instances[0] || new RoutifyRuntime({});
    this.name = name;
    this.urlRewrites = urlRewrite;
    this.log = this.log || this.instance.log.createChild(this.name || "[unnamed instance]");
    if (passthrough && !(passthrough instanceof Router))
      passthrough = (parentCmpCtx == null ? void 0 : parentCmpCtx.route.router) || passthrough;
    this.passthrough = passthrough || this.passthrough;
    appInstance.instances.forEach((inst) => {
      const index = inst.routers.indexOf(this);
      if (index !== -1)
        inst.routers.splice(index, 1);
    });
    this.instance.routers.push(this);
    if (routes && !this.rootNode)
      this.importRoutes(routes);
    this.parentCmpCtx = parentCmpCtx;
    this.rootNode = rootNode || this.rootNode || this.instance.rootNodes.default;
    this.log.debug("initiated router");
    if (this.url.getActive()) {
      this.log.debug("router was created with activeUrl");
      this._setUrl(this.url.getActive(), "pushState", true);
    }
    const shouldInstallUrlReflector = !this.urlReflector || urlReflector && !(this.urlReflector instanceof urlReflector);
    if (shouldInstallUrlReflector) {
      urlReflector = urlReflector || (typeof window != "undefined" ? AddressReflector : InternalReflector);
      this.setUrlReflector(urlReflector);
    }
    if (url2)
      this.url.replace(url2);
    this.triggerStore();
    this.afterRouterInit.run({ router: this, firstInit });
  }
  importRoutes(routes) {
    this.rootNode = this.instance.createNode().importTree(routes);
    this.instance.rootNodes[routes.rootName || "unnamed"] = this.rootNode;
  }
  async _setUrl(url2, mode, isInternal, state = {}) {
    if (!isInternal)
      url2 = this.getInternalUrl(url2);
    url2 = url2 || "/";
    url2 = url2.replace(/(.+)\/+([#?]|$)/, "$1$2");
    const { debug, groupCollapsed, trace, groupEnd } = this.log;
    if (this.log.level >= 4) {
      const info = {
        url: url2,
        mode,
        prev: this.url.internal(),
        browserOld: urlFromAddress(),
        state
      };
      [groupCollapsed("set url", info), trace(), groupEnd()];
    }
    if (!url2.startsWith("/"))
      url2 = url2.replace(new URL(url2).origin, "");
    const currentRoute = this.pendingRoute.get() || this.activeRoute.get();
    const route = new Route(this, url2, mode, state);
    const loadRoutePromise = route.loadRoute();
    if (state.prefetch)
      return;
    if (identicalRoutes(currentRoute, route)) {
      debug("current route is identical - skip", currentRoute, route);
      return false;
    } else {
      route.log.debug("set pending route", route);
      this.pendingRoute.set(route);
      const didLoadRoute = await loadRoutePromise;
      if (this.pendingRoute.get() === route)
        this.pendingRoute.set(null);
      if (didLoadRoute)
        this.setActiveRoute(route);
      await new Promise((resolve) => setTimeout(resolve));
      return true;
    }
  }
  setActiveRoute(route) {
    this.log.debug("set active route", this);
    const $activeRoute = this.activeRoute.get();
    if ($activeRoute)
      this.history.push($activeRoute);
    this.activeRoute.set(route);
    this.afterUrlChange.run({
      route,
      history: [...this.history].reverse()
    });
    this.log.debug("unset pending route", this);
  }
  destroy() {
    this.log.debug(`destroying router`);
    this.instance.routers = this.instance.routers.filter((router) => router !== this);
    this.onDestroy.run({ router: this });
  }
  get urlReflector() {
    return this._urlReflector;
  }
  setUrlReflector(UrlReflector) {
    var _a;
    (_a = this._urlReflector) == null ? void 0 : _a.uninstall();
    this._urlReflector = new UrlReflector(this);
    this._urlReflector.install();
    this.triggerStore();
  }
};
var createRouter = (options) => new Router(options);

// node_modules/@roxi/routify/lib/runtime/renderer/DecoratorWrapper.svelte
function create_else_block2(ctx) {
  let current;
  const default_slot_template = ctx[5].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[6], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[6],
            !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(default_slot_template, ctx2[6], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(23:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = ctx[2].component;
  function switch_props(ctx2) {
    return {
      props: {
        context: ctx2[1],
        isRoot: ctx2[0],
        $$slots: { default: [create_default_slot2] },
        $$scope: { ctx: ctx2 }
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const switch_instance_changes = {};
      if (dirty & 2)
        switch_instance_changes.context = ctx2[1];
      if (dirty & 1)
        switch_instance_changes.isRoot = ctx2[0];
      if (dirty & 74) {
        switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (dirty & 4 && switch_value !== (switch_value = ctx2[2].component)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(17:0) {#if decorator}",
    ctx
  });
  return block;
}
function create_default_slot_1(ctx) {
  let current;
  const default_slot_template = ctx[5].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[6], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[6],
            !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(default_slot_template, ctx2[6], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: "(19:8) <svelte:self decorators={restOfDecorators} {context} isRoot={false}>",
    ctx
  });
  return block;
}
function create_default_slot2(ctx) {
  let decoratorwrapper;
  let current;
  decoratorwrapper = new DecoratorWrapper({
    props: {
      decorators: ctx[3],
      context: ctx[1],
      isRoot: false,
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(decoratorwrapper.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(decoratorwrapper.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(decoratorwrapper, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const decoratorwrapper_changes = {};
      if (dirty & 8)
        decoratorwrapper_changes.decorators = ctx2[3];
      if (dirty & 2)
        decoratorwrapper_changes.context = ctx2[1];
      if (dirty & 64) {
        decoratorwrapper_changes.$$scope = { dirty, ctx: ctx2 };
      }
      decoratorwrapper.$set(decoratorwrapper_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(decoratorwrapper.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(decoratorwrapper.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(decoratorwrapper, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: "(18:4) <svelte:component this={decorator.component} {context} {isRoot}>",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block2, create_else_block2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[2])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DecoratorWrapper", slots, ["default"]);
  let { decorators = null } = $$props;
  let { isRoot = true } = $$props;
  let { context: context2 } = $$props;
  decorators = decorators || context2.decorators;
  let [decorator, ...restOfDecorators] = [...decorators];
  while (decorator && !(decorator == null ? void 0 : decorator.shouldRender({ context: context2, isRoot, decorators })))
    [decorator, ...restOfDecorators] = [...restOfDecorators];
  if (isRoot)
    onDestroy(() => context2.onDestroy.run());
  $$self.$$.on_mount.push(function() {
    if (context2 === void 0 && !("context" in $$props || $$self.$$.bound[$$self.$$.props["context"]])) {
      console.warn("<DecoratorWrapper> was created without expected prop 'context'");
    }
  });
  const writable_props = ["decorators", "isRoot", "context"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<DecoratorWrapper> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("decorators" in $$props2)
      $$invalidate(4, decorators = $$props2.decorators);
    if ("isRoot" in $$props2)
      $$invalidate(0, isRoot = $$props2.isRoot);
    if ("context" in $$props2)
      $$invalidate(1, context2 = $$props2.context);
    if ("$$scope" in $$props2)
      $$invalidate(6, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    onDestroy,
    decorators,
    isRoot,
    context: context2,
    decorator,
    restOfDecorators
  });
  $$self.$inject_state = ($$props2) => {
    if ("decorators" in $$props2)
      $$invalidate(4, decorators = $$props2.decorators);
    if ("isRoot" in $$props2)
      $$invalidate(0, isRoot = $$props2.isRoot);
    if ("context" in $$props2)
      $$invalidate(1, context2 = $$props2.context);
    if ("decorator" in $$props2)
      $$invalidate(2, decorator = $$props2.decorator);
    if ("restOfDecorators" in $$props2)
      $$invalidate(3, restOfDecorators = $$props2.restOfDecorators);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [isRoot, context2, decorator, restOfDecorators, decorators, slots, $$scope];
}
var DecoratorWrapper = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { decorators: 4, isRoot: 0, context: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DecoratorWrapper",
      options,
      id: create_fragment2.name
    });
  }
  get decorators() {
    throw new Error("<DecoratorWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set decorators(value) {
    throw new Error("<DecoratorWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isRoot() {
    throw new Error("<DecoratorWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isRoot(value) {
    throw new Error("<DecoratorWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get context() {
    throw new Error("<DecoratorWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set context(value) {
    throw new Error("<DecoratorWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DecoratorWrapper_default = DecoratorWrapper;

// node_modules/@roxi/routify/lib/runtime/decorators/Noop.svelte
function create_fragment3(ctx) {
  let current;
  const default_slot_template = ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[2],
            !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Noop", slots, ["default"]);
  let { context: context2 = null } = $$props;
  let { Parent = null } = $$props;
  context2;
  Parent;
  const writable_props = ["context", "Parent"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Noop> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("context" in $$props2)
      $$invalidate(0, context2 = $$props2.context);
    if ("Parent" in $$props2)
      $$invalidate(1, Parent = $$props2.Parent);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ context: context2, Parent });
  $$self.$inject_state = ($$props2) => {
    if ("context" in $$props2)
      $$invalidate(0, context2 = $$props2.context);
    if ("Parent" in $$props2)
      $$invalidate(1, Parent = $$props2.Parent);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [context2, Parent, $$scope, slots];
}
var Noop = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { context: 0, Parent: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Noop",
      options,
      id: create_fragment3.name
    });
  }
  get context() {
    throw new Error("<Noop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set context(value) {
    throw new Error("<Noop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get Parent() {
    throw new Error("<Noop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Parent(value) {
    throw new Error("<Noop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Noop_default = Noop;

// node_modules/@roxi/routify/lib/runtime/decorators/AnchorDecorator.svelte
var { Error: Error_1 } = globals;
var file = "node_modules/@roxi/routify/lib/runtime/decorators/AnchorDecorator.svelte";
function create_else_block3(ctx) {
  let t;
  let current;
  let if_block = !ctx[2] && create_if_block_2(ctx);
  const default_slot_template = ctx[6].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      t = space();
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      t = claim_space(nodes);
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_2(ctx2);
          if_block.c();
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[5],
            !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(t);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block3.name,
    type: "else",
    source: "(42:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let div;
  let t;
  let current;
  let div_levels = [ctx[3]];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const default_slot_template = ctx[6].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  const block = {
    c: function create() {
      div = element("div");
      t = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      children(div).forEach(detach_dev);
      t = claim_space(nodes);
      if (default_slot)
        default_slot.l(nodes);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file, 39, 4, 1233);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      ctx[8](div);
      insert_hydration_dev(target, t, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & 8 && ctx2[3]]));
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[5],
            !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      ctx[8](null);
      if (detaching)
        detach_dev(t);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(39:32) ",
    ctx
  });
  return block;
}
function create_if_block3(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[6].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  let div_levels = [ctx[3]];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file, 35, 4, 1128);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[7](div);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[5],
            !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & 8 && ctx2[3]]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      ctx[7](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(35:0) {#if location === 'wrapper'}",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let div;
  let div_levels = [
    { "data-routify-anchor-locator": "" },
    { class: "anchor" },
    ctx[3]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        "data-routify-anchor-locator": true,
        class: true
      });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file, 43, 8, 1323);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      ctx[9](div);
    },
    p: function update(ctx2, dirty) {
      set_attributes(div, div_data = get_spread_update(div_levels, [
        { "data-routify-anchor-locator": "" },
        { class: "anchor" },
        dirty & 8 && ctx2[3]
      ]));
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      ctx[9](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(43:4) {#if !mounted}",
    ctx
  });
  return block;
}
function create_fragment4(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block3, create_if_block_1, create_else_block3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0] === "wrapper")
      return 0;
    if (ctx2[0] === "header")
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  const omit_props_names = ["location", "onMount"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AnchorDecorator", slots, ["default"]);
  let { location: location2 } = $$props;
  let { onMount: onMount2 = (x) => x } = $$props;
  let elem;
  let mounted = false;
  const nextValidSibling = (elem2) => {
    const next2 = elem2.nextElementSibling;
    return next2 && "routifyAnchorLocator" in next2.dataset ? nextValidSibling(next2) : next2;
  };
  onMount(async () => {
    if (location2 === "wrapper")
      onMount2(elem);
    else if (location2 === "parent")
      onMount2(elem.parentNode);
    else if (location2 === "header")
      onMount2(elem.parentElement, elem);
    else if (location2 === "firstChild") {
      const nextSib = nextValidSibling(elem);
      onMount2(elem.parentElement, nextSib);
    } else
      throw new Error(`Incorrect location provided. Got ${location2}`);
    $$invalidate(2, mounted = true);
  });
  $$self.$$.on_mount.push(function() {
    if (location2 === void 0 && !("location" in $$props || $$self.$$.bound[$$self.$$.props["location"]])) {
      console.warn("<AnchorDecorator> was created without expected prop 'location'");
    }
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elem = $$value;
      $$invalidate(1, elem);
    });
  }
  function div_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elem = $$value;
      $$invalidate(1, elem);
    });
  }
  function div_binding_2($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elem = $$value;
      $$invalidate(1, elem);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("location" in $$new_props)
      $$invalidate(0, location2 = $$new_props.location);
    if ("onMount" in $$new_props)
      $$invalidate(4, onMount2 = $$new_props.onMount);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    _onMount: onMount,
    location: location2,
    onMount: onMount2,
    elem,
    mounted,
    nextValidSibling
  });
  $$self.$inject_state = ($$new_props) => {
    if ("location" in $$props)
      $$invalidate(0, location2 = $$new_props.location);
    if ("onMount" in $$props)
      $$invalidate(4, onMount2 = $$new_props.onMount);
    if ("elem" in $$props)
      $$invalidate(1, elem = $$new_props.elem);
    if ("mounted" in $$props)
      $$invalidate(2, mounted = $$new_props.mounted);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    location2,
    elem,
    mounted,
    $$restProps,
    onMount2,
    $$scope,
    slots,
    div_binding,
    div_binding_1,
    div_binding_2
  ];
}
var AnchorDecorator = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, { location: 0, onMount: 4 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AnchorDecorator",
      options,
      id: create_fragment4.name
    });
  }
  get location() {
    throw new Error_1("<AnchorDecorator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set location(value) {
    throw new Error_1("<AnchorDecorator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMount() {
    throw new Error_1("<AnchorDecorator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMount(value) {
    throw new Error_1("<AnchorDecorator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AnchorDecorator_default = AnchorDecorator;

// node_modules/@roxi/routify/lib/runtime/renderer/RenderFragment.svelte
function create_if_block4(ctx) {
  let anchordecorator;
  let current;
  anchordecorator = new AnchorDecorator_default({
    props: {
      location: ctx[0].anchorLocation,
      onMount: ctx[9],
      context: ctx[0],
      $$slots: { default: [create_default_slot3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(anchordecorator.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(anchordecorator.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(anchordecorator, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const anchordecorator_changes = {};
      if (dirty & 1)
        anchordecorator_changes.location = ctx2[0].anchorLocation;
      if (dirty & 1)
        anchordecorator_changes.context = ctx2[0];
      if (dirty & 1048695) {
        anchordecorator_changes.$$scope = { dirty, ctx: ctx2 };
      }
      anchordecorator.$set(anchordecorator_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(anchordecorator.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(anchordecorator.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(anchordecorator, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(43:0) {#if $isVisible && !isAnonFn(NodeComponent)}",
    ctx
  });
  return block;
}
function create_if_block_12(ctx) {
  let compose;
  let current;
  compose = new ComposeFragments_default({
    props: {
      options: {
        inline: ctx[14] || ctx[15],
        decorator: ctx[16],
        props: ctx[1],
        options: ctx[18],
        scrollBoundary: ctx[19],
        anchor: ctx[17] || ctx[0].anchorLocation
      },
      context: ctx[0]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(compose.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(compose.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(compose, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const compose_changes = {};
      if (dirty & 1032195)
        compose_changes.options = {
          inline: ctx2[14] || ctx2[15],
          decorator: ctx2[16],
          props: ctx2[1],
          options: ctx2[18],
          scrollBoundary: ctx2[19],
          anchor: ctx2[17] || ctx2[0].anchorLocation
        };
      if (dirty & 1)
        compose_changes.context = ctx2[0];
      compose.$set(compose_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(compose.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(compose.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(compose, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(61:17) {#if $childFragments.length || (inline && !inline?.single) || (multi && !multi?.single)}",
    ctx
  });
  return block;
}
function create_default_slot_2(ctx) {
  var _a, _b;
  let if_block_anchor;
  let current;
  let if_block = (ctx[6].length || ctx[14] && !((_a = ctx[14]) == null ? void 0 : _a.single) || ctx[15] && !((_b = ctx[15]) == null ? void 0 : _b.single)) && create_if_block_12(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      var _a2, _b2;
      if (ctx2[6].length || ctx2[14] && !((_a2 = ctx2[14]) == null ? void 0 : _a2.single) || ctx2[15] && !((_b2 = ctx2[15]) == null ? void 0 : _b2.single)) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 49216) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_12(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2.name,
    type: "slot",
    source: "(50:12) <svelte:component                 this={NodeComponent}                 {...compProps}                 context={routifyContext}                 let:props                 let:inline                 let:multi                 let:decorator                 let:anchor                 let:options                 let:scrollBoundary                 >",
    ctx
  });
  return block;
}
function create_default_slot_12(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [ctx[5], { context: ctx[4] }];
  var switch_value = ctx[2];
  function switch_props(ctx2) {
    let switch_instance_props = {
      $$slots: {
        default: [
          create_default_slot_2,
          ({ props, inline, multi, decorator, anchor, options, scrollBoundary }) => ({
            1: props,
            14: inline,
            15: multi,
            16: decorator,
            17: anchor,
            18: options,
            19: scrollBoundary
          }),
          ({ props, inline, multi, decorator, anchor, options, scrollBoundary }) => (props ? 2 : 0) | (inline ? 16384 : 0) | (multi ? 32768 : 0) | (decorator ? 65536 : 0) | (anchor ? 131072 : 0) | (options ? 262144 : 0) | (scrollBoundary ? 524288 : 0)
        ]
      },
      $$scope: { ctx: ctx2 }
    };
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const switch_instance_changes = dirty & 48 ? get_spread_update(switch_instance_spread_levels, [
        dirty & 32 && get_spread_object(ctx2[5]),
        dirty & 16 && { context: ctx2[4] }
      ]) : {};
      if (dirty & 2080835) {
        switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (dirty & 4 && switch_value !== (switch_value = ctx2[2])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_12.name,
    type: "slot",
    source: "(48:8) <DecoratorWrapper {context}>",
    ctx
  });
  return block;
}
function create_default_slot3(ctx) {
  let decoratorwrapper;
  let current;
  decoratorwrapper = new DecoratorWrapper_default({
    props: {
      context: ctx[0],
      $$slots: { default: [create_default_slot_12] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(decoratorwrapper.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(decoratorwrapper.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(decoratorwrapper, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const decoratorwrapper_changes = {};
      if (dirty & 1)
        decoratorwrapper_changes.context = ctx2[0];
      if (dirty & 1048695) {
        decoratorwrapper_changes.$$scope = { dirty, ctx: ctx2 };
      }
      decoratorwrapper.$set(decoratorwrapper_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(decoratorwrapper.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(decoratorwrapper.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(decoratorwrapper, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot3.name,
    type: "slot",
    source: "(45:4) <AnchorDecorator location={context.anchorLocation} onMount={initialize} {context}>",
    ctx
  });
  return block;
}
function create_fragment5(ctx) {
  let show_if = ctx[3] && !isAnonFn(ctx[2]);
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block4(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & 12)
        show_if = ctx2[3] && !isAnonFn(ctx2[2]);
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 12) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block4(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  var _a;
  let params2;
  let load;
  let route;
  let compProps;
  let routifyContext;
  let $isVisible;
  let $childFragments;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RenderFragment", slots, []);
  let { context: context2 } = $$props;
  let { props } = $$props;
  const { isVisible, childFragments } = context2;
  validate_store(isVisible, "isVisible");
  component_subscribe($$self, isVisible, (value) => $$invalidate(3, $isVisible = value));
  validate_store(childFragments, "childFragments");
  component_subscribe($$self, childFragments, (value) => $$invalidate(6, $childFragments = value));
  let NodeComponent = ((_a = context2.node.module) == null ? void 0 : _a.default) || context2.node.asyncModule || Noop_default;
  setContext("routify-fragment-context", context2);
  const updateRenderContext = (elem, newMeta) => {
    var _a2;
    elem["__routify_meta"] = {
      ...elem["__routify_meta"],
      renderContext: {
        ...(_a2 = elem["__routify_meta"]) == null ? void 0 : _a2.renderContext,
        ...newMeta
      }
    };
    return elem;
  };
  const initialize = (parent, anchor) => {
    context2.elem.set({ anchor, parent });
    parent = updateRenderContext(parent, { parent: context2 });
    if (anchor)
      anchor = updateRenderContext(anchor, { anchor: context2 });
  };
  $$self.$$.on_mount.push(function() {
    if (context2 === void 0 && !("context" in $$props || $$self.$$.bound[$$self.$$.props["context"]])) {
      console.warn("<RenderFragment> was created without expected prop 'context'");
    }
    if (props === void 0 && !("props" in $$props || $$self.$$.bound[$$self.$$.props["props"]])) {
      console.warn("<RenderFragment> was created without expected prop 'props'");
    }
  });
  const writable_props = ["context", "props"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<RenderFragment> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("context" in $$props2)
      $$invalidate(0, context2 = $$props2.context);
    if ("props" in $$props2)
      $$invalidate(1, props = $$props2.props);
  };
  $$self.$capture_state = () => ({
    Compose: ComposeFragments_default,
    setContext,
    DecoratorWrapper: DecoratorWrapper_default,
    Noop: Noop_default,
    AnchorDecorator: AnchorDecorator_default,
    isAnonFn,
    context: context2,
    props,
    isVisible,
    childFragments,
    NodeComponent,
    updateRenderContext,
    initialize,
    route,
    load,
    routifyContext,
    params: params2,
    compProps,
    $isVisible,
    $childFragments
  });
  $$self.$inject_state = ($$props2) => {
    if ("context" in $$props2)
      $$invalidate(0, context2 = $$props2.context);
    if ("props" in $$props2)
      $$invalidate(1, props = $$props2.props);
    if ("NodeComponent" in $$props2)
      $$invalidate(2, NodeComponent = $$props2.NodeComponent);
    if ("route" in $$props2)
      $$invalidate(10, route = $$props2.route);
    if ("load" in $$props2)
      $$invalidate(11, load = $$props2.load);
    if ("routifyContext" in $$props2)
      $$invalidate(4, routifyContext = $$props2.routifyContext);
    if ("params" in $$props2)
      $$invalidate(12, params2 = $$props2.params);
    if ("compProps" in $$props2)
      $$invalidate(5, compProps = $$props2.compProps);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 13) {
      $:
        if (isAnonFn(NodeComponent) && $isVisible)
          context2.node.loadModule().then((r) => $$invalidate(2, NodeComponent = r.default));
    }
    if ($$self.$$.dirty & 1) {
      $:
        $$invalidate(12, { params: params2, load, route } = context2.fragment, params2, ($$invalidate(11, load), $$invalidate(0, context2)), ($$invalidate(10, route), $$invalidate(0, context2)));
    }
    if ($$self.$$.dirty & 6146) {
      $:
        $$invalidate(5, compProps = { ...params2, ...load == null ? void 0 : load.props, ...props });
    }
    if ($$self.$$.dirty & 3073) {
      $:
        $$invalidate(4, routifyContext = { ...context2, load, route });
    }
  };
  return [
    context2,
    props,
    NodeComponent,
    $isVisible,
    routifyContext,
    compProps,
    $childFragments,
    isVisible,
    childFragments,
    initialize,
    route,
    load,
    params2
  ];
}
var RenderFragment = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, { context: 0, props: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RenderFragment",
      options,
      id: create_fragment5.name
    });
  }
  get context() {
    throw new Error("<RenderFragment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set context(value) {
    throw new Error("<RenderFragment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get props() {
    throw new Error("<RenderFragment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set props(value) {
    throw new Error("<RenderFragment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RenderFragment_default = RenderFragment;

// node_modules/@roxi/routify/lib/runtime/renderer/utils/normalizeInline.js
var nodeIsPage = (node2) => {
  var _a;
  return !node2.meta.fallback && !node2.name.startsWith("_") && ((_a = node2.meta) == null ? void 0 : _a.order) !== false;
};
var getChildren = (refNode, parentContext) => {
  const parentNode = (parentContext == null ? void 0 : parentContext.node) || refNode.parent;
  const matches = parentNode ? parentNode.children.filter((node2) => node2 === refNode || nodeIsPage(node2)) : [refNode];
  return matches.length ? matches : [refNode];
};
var coerceStringToNode = (nodeOrString, refNode) => typeof nodeOrString === "string" ? refNode.traverse(nodeOrString) : nodeOrString;
var coercePagesToNodes = (pagesInput, refNode, parentContext) => {
  const pageInputs = Array.isArray(pagesInput) ? pagesInput : getChildren(refNode, parentContext);
  return pageInputs.map((page) => coerceStringToNode(page, refNode));
};
var convertToObj = (inlineInput) => inlineInput instanceof Object ? !Array.isArray(inlineInput) ? inlineInput : { pages: inlineInput } : {};
var normalizeInline = (inlineInput, refNode, parentContext) => {
  const inline = convertToObj(inlineInput);
  inline.single = inline.single || !inlineInput;
  inline.pages = coercePagesToNodes(inline.pages, refNode, parentContext);
  inline.renderInactive = inline.renderInactive || "browser";
  return inline;
};

// node_modules/@roxi/routify/lib/runtime/renderer/utils/normalizeDecorator.js
var decoratorDefaults = { recursive: true, shouldRender: () => true };
var normalizeDecorator = (decorator) => {
  if ("component" in decorator)
    return { ...decoratorDefaults, ...decorator };
  else
    return { ...decoratorDefaults, component: decorator };
};

// node_modules/@roxi/routify/lib/runtime/renderer/ComposeFragments.svelte
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[0] = list[i];
  return child_ctx;
}
function create_if_block5(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ctx[1];
  validate_each_argument(each_value);
  const get_key = (ctx2) => ctx2[0].node.id;
  validate_each_keys(ctx, each_value, get_each_context, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & 34) {
        each_value = ctx2[1];
        validate_each_argument(each_value);
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block, each_1_anchor, get_each_context);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block5.name,
    type: "if",
    source: "(144:0) {#if !wait}",
    ctx
  });
  return block;
}
function create_each_block(key_1, ctx) {
  let first;
  let renderfragment;
  let current;
  renderfragment = new RenderFragment_default({
    props: {
      context: ctx[0],
      props: ctx[5]
    },
    $$inline: true
  });
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      create_component(renderfragment.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      claim_component(renderfragment.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      mount_component(renderfragment, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const renderfragment_changes = {};
      if (dirty & 2)
        renderfragment_changes.context = ctx[0];
      renderfragment.$set(renderfragment_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(renderfragment.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(renderfragment.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(first);
      destroy_component(renderfragment, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(145:4) {#each childContexts as context (context.node.id)}",
    ctx
  });
  return block;
}
function create_fragment6(ctx) {
  let if_block_anchor;
  let current;
  let if_block = !ctx[2] && create_if_block5(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (!ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block5(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  var _a;
  let $childFragments;
  let $isActive;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ComposeFragments", slots, []);
  const isRoot = void 0;
  let { context: context2 = null } = $$props;
  let { options } = $$props;
  const environment = typeof window !== "undefined" ? "browser" : "ssr";
  let activeContext;
  const { childFragments, isActive: isActive2, route } = context2;
  validate_store(childFragments, "childFragments");
  component_subscribe($$self, childFragments, (value) => $$invalidate(8, $childFragments = value));
  validate_store(isActive2, "isActive");
  component_subscribe($$self, isActive2, (value) => $$invalidate(9, $isActive = value));
  const { inline: multiInput, decorator, props, anchor: anchorLocation, options: _options, scrollBoundary = (elem) => elem.parentElement } = options;
  const getChildIndex = (node2) => node2.children.find((node3) => node3.name === "index");
  const recursiveDecorators = context2.decorators.filter((deco) => deco.recursive);
  const newDecorators = pushToOrReplace(recursiveDecorators, decorator).filter(Boolean).map(normalizeDecorator);
  const folderDecorator = (_a = context2 == null ? void 0 : context2.node) == null ? void 0 : _a.children.find((node2) => node2.name === "_decorator");
  const addFolderDecorator = (decorators, folderDecorator2) => {
    var _a2, _b, _c;
    const options2 = folderDecorator2.module.options || {};
    decorators.push({
      component: folderDecorator2.module.default,
      recursive: (_b = (_a2 = options2.recursive) != null ? _a2 : folderDecorator2.meta.recursive) != null ? _b : true,
      shouldRender: (_c = options2.shouldRender) != null ? _c : () => true
    });
  };
  let wait = false;
  if (folderDecorator) {
    if (folderDecorator.module)
      addFolderDecorator(newDecorators, folderDecorator);
    else {
      wait = true;
      folderDecorator.loadModule().then(() => {
        addFolderDecorator(newDecorators, folderDecorator);
        $$invalidate(2, wait = false);
      });
    }
  }
  const buildChildContexts = () => {
    var _a2;
    const inline = normalizeInline(multiInput, (_a2 = $childFragments[0]) == null ? void 0 : _a2.node, context2);
    return inline.pages.map((node2) => {
      var _a3, _b;
      return {
        anchorLocation: anchorLocation || "parent",
        childFragments: writable(getChildIndex(node2) ? [new RouteFragment(route, getChildIndex(node2))] : []),
        node: node2,
        fragment: new RouteFragment(route, node2, null, {}),
        isActive: writable(false),
        isVisible: writable(false),
        elem: writable(null),
        router: ((_b = (_a3 = $childFragments[0]) == null ? void 0 : _a3.route) == null ? void 0 : _b.router) || context2.router,
        route: null,
        parentContext: context2,
        onDestroy: createSequenceHooksCollection(),
        decorators: newDecorators,
        options: _options || {},
        scrollBoundary,
        inline,
        single: writable(inline.single)
      };
    });
  };
  let childContexts = buildChildContexts();
  const handlePageChange = (fragments) => {
    const [fragment, ...childFragments2] = [...fragments];
    activeContext = childContexts.find((s) => s.node === (fragment == null ? void 0 : fragment.node));
    if (!activeContext) {
      $$invalidate(1, childContexts = buildChildContexts());
      return handlePageChange(fragments);
    }
    activeContext.fragment = fragment;
    activeContext.childFragments.set(childFragments2);
    activeContext.route = fragments[0].route;
    $$invalidate(1, childContexts);
  };
  const setVisibility = (childContexts2) => {
    childContexts2.forEach((context3) => {
      const notExcludedCtx = (context4) => {
        var _a2, _b;
        return !((_b = (_a2 = context4 == null ? void 0 : context4.node) == null ? void 0 : _a2.meta.inline) == null ? void 0 : _b.exclude);
      };
      const isPartOfPage = () => {
        var _a2;
        return !get_store_value(activeContext == null ? void 0 : activeContext.single) && !get_store_value(context3.single) && [context3, activeContext].every(notExcludedCtx) && ["always", environment].includes((_a2 = context3.inline) == null ? void 0 : _a2.renderInactive);
      };
      const isActive3 = context3 === activeContext;
      const wasActive = get_store_value(context3.isActive);
      if (wasActive != isActive3)
        context3.isActive.set(isActive3);
      const isVisible = isActive3 || isPartOfPage();
      const wasVisible = get_store_value(context3.isVisible);
      if (wasVisible != isVisible)
        context3.isVisible.set(isVisible);
    });
  };
  $$self.$$.on_mount.push(function() {
    if (options === void 0 && !("options" in $$props || $$self.$$.bound[$$self.$$.props["options"]])) {
      console.warn("<ComposeFragments> was created without expected prop 'options'");
    }
  });
  const writable_props = ["context", "options"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ComposeFragments> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("context" in $$props2)
      $$invalidate(0, context2 = $$props2.context);
    if ("options" in $$props2)
      $$invalidate(7, options = $$props2.options);
  };
  $$self.$capture_state = () => ({
    createSequenceHooksCollection,
    get: get_store_value,
    writable,
    RouteFragment,
    pushToOrReplace,
    RenderFragment: RenderFragment_default,
    normalizeDecorator,
    normalizeInline,
    isRoot,
    context: context2,
    options,
    environment,
    activeContext,
    childFragments,
    isActive: isActive2,
    route,
    multiInput,
    decorator,
    props,
    anchorLocation,
    _options,
    scrollBoundary,
    getChildIndex,
    recursiveDecorators,
    newDecorators,
    folderDecorator,
    addFolderDecorator,
    wait,
    buildChildContexts,
    childContexts,
    handlePageChange,
    setVisibility,
    $childFragments,
    $isActive
  });
  $$self.$inject_state = ($$props2) => {
    if ("context" in $$props2)
      $$invalidate(0, context2 = $$props2.context);
    if ("options" in $$props2)
      $$invalidate(7, options = $$props2.options);
    if ("activeContext" in $$props2)
      activeContext = $$props2.activeContext;
    if ("wait" in $$props2)
      $$invalidate(2, wait = $$props2.wait);
    if ("childContexts" in $$props2)
      $$invalidate(1, childContexts = $$props2.childContexts);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 514) {
      $:
        if (!$isActive)
          childContexts.forEach((cc) => cc.isActive.set(false));
    }
    if ($$self.$$.dirty & 256) {
      $:
        $childFragments.length && handlePageChange($childFragments);
    }
    if ($$self.$$.dirty & 2) {
      $:
        setVisibility(childContexts);
    }
  };
  return [
    context2,
    childContexts,
    wait,
    childFragments,
    isActive2,
    props,
    isRoot,
    options,
    $childFragments,
    $isActive
  ];
}
var ComposeFragments = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, { isRoot: 6, context: 0, options: 7 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ComposeFragments",
      options,
      id: create_fragment6.name
    });
  }
  get isRoot() {
    return this.$$.ctx[6];
  }
  set isRoot(value) {
    throw new Error("<ComposeFragments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get context() {
    throw new Error("<ComposeFragments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set context(value) {
    throw new Error("<ComposeFragments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get options() {
    throw new Error("<ComposeFragments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<ComposeFragments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ComposeFragments_default = ComposeFragments;

// node_modules/@roxi/routify/lib/runtime/helpers/scroll.js
var persistentScopedScrollIntoView = (_elem, _boundary, options, timeout) => {
  let elem = resolveIfAnonFn(_elem, [_boundary]);
  const boundary = resolveIfAnonFn(_boundary, [elem]);
  options = options || {};
  options.behavior = "auto";
  scopedScrollIntoView(elem, boundary);
  const observer = new MutationObserver((mo) => {
    if (mo.length > 1 || mo[0].addedNodes.length || mo[0].removedNodes.length) {
      scopedScrollIntoView(elem, boundary);
    }
  });
  observer.observe(document.body, {
    childList: true,
    subtree: true,
    attributes: true,
    characterData: true
  });
  const stopScroll = () => observer.disconnect();
  if (timeout) {
    return new Promise(
      (resolve) => setTimeout(() => {
        stopScroll();
        resolve();
      }, timeout)
    );
  } else {
    timeout;
    return stopScroll;
  }
};
var getScrollBoundaries = () => [
  ...document.querySelectorAll('[data-routify-scroll="lock"]'),
  ...appInstance.routers.filter((router) => router.parentCmpCtx).map((router) => router.parentElem)
];
var getMulti = (elem) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
  if (!elem)
    return false;
  if ((_a = elem["__routify_meta"]) == null ? void 0 : _a.router)
    return false;
  if ((_d = (_c = (_b = elem["__routify_meta"]) == null ? void 0 : _b.renderContext) == null ? void 0 : _c.anchor) == null ? void 0 : _d.single)
    return !get_store_value((_g = (_f = (_e = elem["__routify_meta"]) == null ? void 0 : _e.renderContext) == null ? void 0 : _f.anchor) == null ? void 0 : _g.single);
  if ((_j = (_i = (_h = elem["__routify_meta"]) == null ? void 0 : _h.renderContext) == null ? void 0 : _i.parent) == null ? void 0 : _j.single)
    return !get_store_value((_m = (_l = (_k = elem["__routify_meta"]) == null ? void 0 : _k.renderContext) == null ? void 0 : _l.parent) == null ? void 0 : _m.single);
  else
    return getMulti(elem.parentElement);
};
var scopedScrollIntoView = async (_elem, _boundary) => {
  let elem = await resolveIfAnonFn(_elem, [_boundary]);
  const boundary = await resolveIfAnonFn(_boundary, [elem]);
  let parent = elem.parentElement;
  while ((parent == null ? void 0 : parent.scrollTo) && parent.dataset["routifyScroll"] !== "lock" && parent !== (boundary == null ? void 0 : boundary.parentElement)) {
    const scrollToPos = getMulti(elem) || elem["routify-hash-nav"];
    if (!scrollToPos) {
      parent.scrollTo(0, 0);
    } else {
      const targetRect = elem.getBoundingClientRect();
      const parentRect = parent.getBoundingClientRect();
      const scrollTop = parent.parentElement ? parent.scrollTop : 0;
      const scrollLeft = parent.parentElement ? parent.scrollLeft : 0;
      const top = scrollTop + targetRect.top - parentRect.top;
      const left = scrollLeft + targetRect.left - parentRect.left;
      parent.scrollTo({ top, left });
    }
    if (!scrollToPos)
      elem = parent;
    parent = parent.parentElement;
  }
};
var scrollToContext = async (context2) => {
  const { anchor, parent } = await waitFor(context2.elem, Boolean);
  const scrollTarget = anchor || parent;
  let scrollBoundary = await context2.scrollBoundary;
  scopedScrollIntoView(scrollTarget, scrollBoundary);
};

// node_modules/@roxi/routify/lib/runtime/decorators/ScrollDecorator.svelte
function create_fragment7(ctx) {
  let current;
  const default_slot_template = ctx[5].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[4], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[4],
            !current ? get_all_dirty_from_scope(ctx2[4]) : get_slot_changes(default_slot_template, ctx2[4], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var hashScroll = (route) => {
  setTimeout(
    async () => {
      var _a;
      const hashElem = (_a = globalThis.document) == null ? void 0 : _a.getElementById(route == null ? void 0 : route.hash);
      if (hashElem) {
        hashElem["routify-hash-nav"] = "true";
        await persistentScopedScrollIntoView(hashElem, null, {}, 500);
        delete hashElem["routify-hash-nav"];
      }
    },
    0
  );
};
function instance7($$self, $$props, $$invalidate) {
  let route;
  let isActive2;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ScrollDecorator", slots, ["default"]);
  let { context: context2 } = $$props;
  const isRoot = void 0;
  $$self.$$.on_mount.push(function() {
    if (context2 === void 0 && !("context" in $$props || $$self.$$.bound[$$self.$$.props["context"]])) {
      console.warn("<ScrollDecorator> was created without expected prop 'context'");
    }
  });
  const writable_props = ["context"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ScrollDecorator> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("context" in $$props2)
      $$invalidate(0, context2 = $$props2.context);
    if ("$$scope" in $$props2)
      $$invalidate(4, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    get: get_store_value,
    scrollToContext,
    persistentScopedScrollIntoView,
    hashScroll,
    context: context2,
    isRoot,
    route,
    isActive: isActive2
  });
  $$self.$inject_state = ($$props2) => {
    if ("context" in $$props2)
      $$invalidate(0, context2 = $$props2.context);
    if ("route" in $$props2)
      $$invalidate(2, route = $$props2.route);
    if ("isActive" in $$props2)
      $$invalidate(3, isActive2 = $$props2.isActive);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $:
        $$invalidate(2, { route, isActive: isActive2 } = context2, route, ($$invalidate(3, isActive2), $$invalidate(0, context2)));
    }
    if ($$self.$$.dirty & 13) {
      $:
        if (route == null ? void 0 : route.hash)
          hashScroll(route);
        else if (get_store_value(isActive2) && !(route == null ? void 0 : route.state.dontScroll))
          scrollToContext(context2);
    }
  };
  return [context2, isRoot, route, isActive2, $$scope, slots];
}
var ScrollDecorator = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, { context: 0, isRoot: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ScrollDecorator",
      options,
      id: create_fragment7.name
    });
  }
  get context() {
    throw new Error("<ScrollDecorator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set context(value) {
    throw new Error("<ScrollDecorator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isRoot() {
    return this.$$.ctx[1];
  }
  set isRoot(value) {
    throw new Error("<ScrollDecorator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ScrollDecorator_default = ScrollDecorator;

// node_modules/@roxi/routify/lib/runtime/Router/Router.svelte
function create_if_block6(ctx) {
  let component;
  let current;
  component = new ComposeFragments_default({
    props: {
      context: ctx[4],
      options: { decorator: ctx[0] }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(component.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(component.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(component, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const component_changes = {};
      if (dirty & 1)
        component_changes.options = { decorator: ctx2[0] };
      component.$set(component_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(component.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(component.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(component, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block6.name,
    type: "if",
    source: "(132:4) {#if $activeRoute}",
    ctx
  });
  return block;
}
function create_default_slot4(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[2] && create_if_block6(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block6(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot4.name,
    type: "slot",
    source: '(131:0) <AnchorDecorator onMount={initialize} style=\\"display: contents\\" location={anchor}>',
    ctx
  });
  return block;
}
function create_fragment8(ctx) {
  let anchordecorator;
  let current;
  anchordecorator = new AnchorDecorator_default({
    props: {
      onMount: ctx[5],
      style: "display: contents",
      location: ctx[1],
      $$slots: { default: [create_default_slot4] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(anchordecorator.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(anchordecorator.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(anchordecorator, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const anchordecorator_changes = {};
      if (dirty & 2)
        anchordecorator_changes.location = ctx2[1];
      if (dirty & 134217733) {
        anchordecorator_changes.$$scope = { dirty, ctx: ctx2 };
      }
      anchordecorator.$set(anchordecorator_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(anchordecorator.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(anchordecorator.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(anchordecorator, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance_1($$self, $$props, $$invalidate) {
  let activeRoute2;
  let $activeRoute, $$unsubscribe_activeRoute = noop, $$subscribe_activeRoute = () => ($$unsubscribe_activeRoute(), $$unsubscribe_activeRoute = subscribe(activeRoute2, ($$value) => $$invalidate(2, $activeRoute = $$value)), activeRoute2);
  $$self.$$.on_destroy.push(() => $$unsubscribe_activeRoute());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Router", slots, []);
  let { router = null } = $$props;
  let { routes = null } = $$props;
  let { decorator = null } = $$props;
  let { urlReflector = null } = $$props;
  let { instance: instance8 = null } = $$props;
  let { urlRewrite = null } = $$props;
  let { url: url2 = null } = $$props;
  let { name = null } = $$props;
  let { rootNode = null } = $$props;
  let { passthrough = null } = $$props;
  let { beforeRouterInit = null } = $$props;
  let { afterRouterInit = null } = $$props;
  let { beforeUrlChange: beforeUrlChange2 = null } = $$props;
  let { afterUrlChange: afterUrlChange2 = null } = $$props;
  let { transformFragments = null } = $$props;
  let { onDestroy: onDestroy2 = null } = $$props;
  let { plugins = null } = $$props;
  let { queryHandler = null } = $$props;
  let { anchor = "wrapper" } = $$props;
  let { clickHandler = {} } = $$props;
  const context2 = {
    childFragments: writable([]),
    decorators: [normalizeDecorator(ScrollDecorator_default)]
  };
  const options = {
    instance: instance8,
    rootNode,
    name,
    routes,
    urlRewrite,
    urlReflector,
    passthrough,
    beforeRouterInit,
    afterRouterInit,
    beforeUrlChange: beforeUrlChange2,
    afterUrlChange: afterUrlChange2,
    transformFragments,
    onDestroy: onDestroy2,
    plugins,
    queryHandler,
    clickHandler
  };
  if (!router)
    router = new Router(options);
  const initialize = (elem) => {
    var _a;
    elem = anchor === "parent" || anchor === "wrapper" ? elem : elem.parentElement;
    router.setParentElem(elem);
    elem["__routify_meta"] = { ...elem["__routify_meta"], router };
    let clickScopeElem = resolveIfAnonFn(((_a = router.clickHandler) == null ? void 0 : _a.elem) || elem, [elem]);
    if (!router.passthrough) {
      clickScopeElem.addEventListener("click", handleClick);
      clickScopeElem.addEventListener("keydown", handleClick);
      clickScopeElem.addEventListener("mouseover", handleHover);
    }
  };
  const handleHover = (event) => {
    var _a, _b, _c, _d;
    const eventUrl = getUrlFromEvent(event);
    const url3 = (_c = (_b = (_a = router.clickHandler).callback) == null ? void 0 : _b.call(_a, event, eventUrl)) != null ? _c : eventUrl;
    const shouldPrefetch = typeof url3 === "string" && ((_d = event.target.closest("[data-routify-prefetch-data]")) == null ? void 0 : _d.dataset.routifyPrefetchData) === "hover";
    if (shouldPrefetch)
      router.url.push(url3, { prefetch: true });
  };
  const handleClick = (event) => {
    var _a, _b, _c;
    if (shouldIgnoreClick(event))
      return;
    const eventUrl = getUrlFromEvent(event);
    const url3 = (_c = (_b = (_a = router.clickHandler).callback) == null ? void 0 : _b.call(_a, event, eventUrl)) != null ? _c : eventUrl;
    if (typeof url3 === "string")
      router.url.push(url3);
  };
  if (typeof window !== "undefined")
    onDestroy(() => router.destroy());
  const writable_props = [
    "router",
    "routes",
    "decorator",
    "urlReflector",
    "instance",
    "urlRewrite",
    "url",
    "name",
    "rootNode",
    "passthrough",
    "beforeRouterInit",
    "afterRouterInit",
    "beforeUrlChange",
    "afterUrlChange",
    "transformFragments",
    "onDestroy",
    "plugins",
    "queryHandler",
    "anchor",
    "clickHandler"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Router> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("router" in $$props2)
      $$invalidate(6, router = $$props2.router);
    if ("routes" in $$props2)
      $$invalidate(7, routes = $$props2.routes);
    if ("decorator" in $$props2)
      $$invalidate(0, decorator = $$props2.decorator);
    if ("urlReflector" in $$props2)
      $$invalidate(8, urlReflector = $$props2.urlReflector);
    if ("instance" in $$props2)
      $$invalidate(9, instance8 = $$props2.instance);
    if ("urlRewrite" in $$props2)
      $$invalidate(10, urlRewrite = $$props2.urlRewrite);
    if ("url" in $$props2)
      $$invalidate(11, url2 = $$props2.url);
    if ("name" in $$props2)
      $$invalidate(12, name = $$props2.name);
    if ("rootNode" in $$props2)
      $$invalidate(13, rootNode = $$props2.rootNode);
    if ("passthrough" in $$props2)
      $$invalidate(14, passthrough = $$props2.passthrough);
    if ("beforeRouterInit" in $$props2)
      $$invalidate(15, beforeRouterInit = $$props2.beforeRouterInit);
    if ("afterRouterInit" in $$props2)
      $$invalidate(16, afterRouterInit = $$props2.afterRouterInit);
    if ("beforeUrlChange" in $$props2)
      $$invalidate(17, beforeUrlChange2 = $$props2.beforeUrlChange);
    if ("afterUrlChange" in $$props2)
      $$invalidate(18, afterUrlChange2 = $$props2.afterUrlChange);
    if ("transformFragments" in $$props2)
      $$invalidate(19, transformFragments = $$props2.transformFragments);
    if ("onDestroy" in $$props2)
      $$invalidate(20, onDestroy2 = $$props2.onDestroy);
    if ("plugins" in $$props2)
      $$invalidate(21, plugins = $$props2.plugins);
    if ("queryHandler" in $$props2)
      $$invalidate(22, queryHandler = $$props2.queryHandler);
    if ("anchor" in $$props2)
      $$invalidate(1, anchor = $$props2.anchor);
    if ("clickHandler" in $$props2)
      $$invalidate(23, clickHandler = $$props2.clickHandler);
  };
  $$self.$capture_state = () => ({
    Router,
    _onDestroy: onDestroy,
    getUrlFromEvent,
    resolveIfAnonFn,
    shouldIgnoreClick,
    Component: ComposeFragments_default,
    ScrollDecorator: ScrollDecorator_default,
    get: get_store_value,
    writable,
    AnchorDecorator: AnchorDecorator_default,
    normalizeDecorator,
    router,
    routes,
    decorator,
    urlReflector,
    instance: instance8,
    urlRewrite,
    url: url2,
    name,
    rootNode,
    passthrough,
    beforeRouterInit,
    afterRouterInit,
    beforeUrlChange: beforeUrlChange2,
    afterUrlChange: afterUrlChange2,
    transformFragments,
    onDestroy: onDestroy2,
    plugins,
    queryHandler,
    anchor,
    clickHandler,
    context: context2,
    options,
    initialize,
    handleHover,
    handleClick,
    activeRoute: activeRoute2,
    $activeRoute
  });
  $$self.$inject_state = ($$props2) => {
    if ("router" in $$props2)
      $$invalidate(6, router = $$props2.router);
    if ("routes" in $$props2)
      $$invalidate(7, routes = $$props2.routes);
    if ("decorator" in $$props2)
      $$invalidate(0, decorator = $$props2.decorator);
    if ("urlReflector" in $$props2)
      $$invalidate(8, urlReflector = $$props2.urlReflector);
    if ("instance" in $$props2)
      $$invalidate(9, instance8 = $$props2.instance);
    if ("urlRewrite" in $$props2)
      $$invalidate(10, urlRewrite = $$props2.urlRewrite);
    if ("url" in $$props2)
      $$invalidate(11, url2 = $$props2.url);
    if ("name" in $$props2)
      $$invalidate(12, name = $$props2.name);
    if ("rootNode" in $$props2)
      $$invalidate(13, rootNode = $$props2.rootNode);
    if ("passthrough" in $$props2)
      $$invalidate(14, passthrough = $$props2.passthrough);
    if ("beforeRouterInit" in $$props2)
      $$invalidate(15, beforeRouterInit = $$props2.beforeRouterInit);
    if ("afterRouterInit" in $$props2)
      $$invalidate(16, afterRouterInit = $$props2.afterRouterInit);
    if ("beforeUrlChange" in $$props2)
      $$invalidate(17, beforeUrlChange2 = $$props2.beforeUrlChange);
    if ("afterUrlChange" in $$props2)
      $$invalidate(18, afterUrlChange2 = $$props2.afterUrlChange);
    if ("transformFragments" in $$props2)
      $$invalidate(19, transformFragments = $$props2.transformFragments);
    if ("onDestroy" in $$props2)
      $$invalidate(20, onDestroy2 = $$props2.onDestroy);
    if ("plugins" in $$props2)
      $$invalidate(21, plugins = $$props2.plugins);
    if ("queryHandler" in $$props2)
      $$invalidate(22, queryHandler = $$props2.queryHandler);
    if ("anchor" in $$props2)
      $$invalidate(1, anchor = $$props2.anchor);
    if ("clickHandler" in $$props2)
      $$invalidate(23, clickHandler = $$props2.clickHandler);
    if ("activeRoute" in $$props2)
      $$subscribe_activeRoute($$invalidate(3, activeRoute2 = $$props2.activeRoute));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2112) {
      $:
        if (url2 && url2 !== router.url.internal())
          router.url.replace(url2);
    }
    if ($$self.$$.dirty & 64) {
      $:
        $$subscribe_activeRoute($$invalidate(3, activeRoute2 = router.activeRoute));
    }
    if ($$self.$$.dirty & 4) {
      $:
        context2.childFragments.set(($activeRoute == null ? void 0 : $activeRoute.fragments) || []);
    }
    if ($$self.$$.dirty & 64) {
      $:
        router.log.debug("before render", get_store_value(context2.childFragments));
    }
  };
  return [
    decorator,
    anchor,
    $activeRoute,
    activeRoute2,
    context2,
    initialize,
    router,
    routes,
    urlReflector,
    instance8,
    urlRewrite,
    url2,
    name,
    rootNode,
    passthrough,
    beforeRouterInit,
    afterRouterInit,
    beforeUrlChange2,
    afterUrlChange2,
    transformFragments,
    onDestroy2,
    plugins,
    queryHandler,
    clickHandler
  ];
}
var Router_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance_1, create_fragment8, safe_not_equal, {
      router: 6,
      routes: 7,
      decorator: 0,
      urlReflector: 8,
      instance: 9,
      urlRewrite: 10,
      url: 11,
      name: 12,
      rootNode: 13,
      passthrough: 14,
      beforeRouterInit: 15,
      afterRouterInit: 16,
      beforeUrlChange: 17,
      afterUrlChange: 18,
      transformFragments: 19,
      onDestroy: 20,
      plugins: 21,
      queryHandler: 22,
      anchor: 1,
      clickHandler: 23
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Router_1",
      options,
      id: create_fragment8.name
    });
  }
  get router() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set router(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get routes() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set routes(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get decorator() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set decorator(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get urlReflector() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set urlReflector(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get instance() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set instance(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get urlRewrite() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set urlRewrite(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get url() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set url(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rootNode() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rootNode(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get passthrough() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set passthrough(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get beforeRouterInit() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set beforeRouterInit(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get afterRouterInit() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set afterRouterInit(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get beforeUrlChange() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set beforeUrlChange(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get afterUrlChange() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set afterUrlChange(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transformFragments() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transformFragments(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onDestroy() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onDestroy(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get plugins() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set plugins(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get queryHandler() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set queryHandler(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get anchor() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set anchor(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clickHandler() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clickHandler(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Router_default = Router_1;

// node_modules/@roxi/routify/lib/runtime/Router/urlReflectors/LocalStorage.js
var LocalStorageReflector = class extends BaseReflector {
  constructor(router) {
    super(router);
    this.storageName = `__routify-router-${this.router.name}`;
  }
  reflect() {
    window.localStorage.setItem(this.storageName, this.router.url.internal());
  }
  install() {
    const url2 = window.localStorage.getItem(this.storageName);
    this.router.url.replace(url2 || "/");
  }
};

// node_modules/@roxi/routify/lib/runtime/helpers/index.js
var getMRCA = (node1, node2) => {
  const lineage1 = [node1, ...node1.ancestors];
  const lineage2 = [node2, ...node2.ancestors];
  return lineage1.find((node3) => lineage2.includes(node3));
};
var getPath = (node1, node2) => {
  const lineage1 = [node1, ...node1.ancestors];
  const lineage2 = [node2, ...node2.ancestors];
  const mrca = getMRCA(node1, node2);
  const backtrackSteps = lineage1.indexOf(mrca);
  const backtrackStr = backtrackSteps ? "../".repeat(backtrackSteps) : "";
  const forwardSteps = lineage2.indexOf(mrca);
  const forwardStepsStr = lineage2.slice(0, forwardSteps).reverse().map((n) => n.name).join("/");
  return backtrackStr + forwardStepsStr;
};
var goto = {
  subscribe: (run, invalidate) => {
    const { router } = contexts;
    return derived(url, ($url) => (path, userParams, options) => {
      const defaults2 = { mode: "push", state: {} };
      options = { ...defaults2, ...options };
      const newUrl = $url(path, userParams);
      router.url[options.mode](newUrl, options.state);
    }).subscribe(run, invalidate);
  }
};
var url = {
  subscribe: (run, invalidate) => {
    const { router } = contexts;
    const originalOriginNode = contexts.fragment.node;
    return derived(router.activeRoute, (activeRoute2) => {
      const originNode = router.rootNode.traverse(originalOriginNode.path);
      return (inputPath, userParams = {}) => {
        const offset = inputPath.startsWith("/") ? router.rootNode.path : "";
        const targetNode = originNode.traverse(offset + inputPath);
        if (!targetNode) {
          console.error("could not find destination node", inputPath);
          return;
        }
        const mrca = getMRCA(targetNode, router.rootNode);
        const path = ("/" + getPath(mrca, targetNode)).replace(/\/index$/, "/");
        const params2 = {
          ...inheritedParams(targetNode, activeRoute2),
          ...userParams
        };
        const internalUrl = populateUrl(path, params2, activeRoute2);
        return router.getExternalUrl(internalUrl);
      };
    }).subscribe(run, invalidate);
  }
};
var inheritedParams = (node2, route) => {
  const lineage = [node2, ...node2.ancestors].reverse();
  const params2 = lineage.map(
    (_node) => {
      var _a;
      return (_a = route.allFragments.find(
        (fragment) => fragment.node === _node || fragment.node.path === _node.path
      )) == null ? void 0 : _a.params;
    }
  );
  return Object.assign({}, ...params2);
};
var params = {
  subscribe: (run, invalidate) => derived(contexts.router.params, (params2) => params2).subscribe(run, invalidate)
};
var isActive = {
  subscribe: (run, invalidate) => derived(contexts.router.activeRoute, isActiveRoute).subscribe(run, invalidate)
};
var isActiveRoute = ($route) => isActiveUrl($route.url, $route.params);
var isActiveUrl = (url2, actualParams = {}) => {
  const stripLastIndexAndSlash = (str) => str.replace(/(\/index)?\/*$/, "");
  url2 = url2.replace(/[?#].+/, "");
  url2 = stripLastIndexAndSlash(url2);
  return (path, params2 = {}, options = {}) => {
    const { recursive } = { recursive: true, ...options };
    for (const wantedParam of Object.keys(params2))
      if (actualParams[wantedParam] !== params2[wantedParam])
        return false;
    path = pathAndParamsToUrl(path, { ...actualParams, ...params2 }, (x) => "", true);
    path = stripLastIndexAndSlash(path);
    const suffix = recursive ? "(/|$)" : "/?$";
    const regexPath = new RegExp(`^${path}${suffix}`);
    return regexPath.test(url2);
  };
};
var resolveNode = (path) => {
  const { node: node2 } = contexts.fragment;
  const { router } = contexts;
  return traverseNode(node2, path, router);
};
var traverseNode = (node2, path, router) => path.startsWith("/") ? router.rootNode.traverse(`.${path}`) : node2.traverse(path);
var pseudoStore = (callback) => ({
  subscribe: (run) => {
    run(callback());
    return () => {
    };
  }
});
var context = pseudoStore(() => contexts.fragment);
var node = pseudoStore(() => get_store_value(context).node);
var meta = pseudoStore(() => get_store_value(node).meta);
var activeRoute = {
  subscribe: (run) => contexts.router.activeRoute.subscribe(run)
};
var pendingRoute = {
  subscribe: (run) => contexts.router.pendingRoute.subscribe(run)
};
var afterUrlChange = {
  subscribe: (run) => {
    const hookHandles = [];
    const register = (callback) => {
      const unhook = contexts.router.afterUrlChange(callback);
      hookHandles.push(unhook);
      return unhook;
    };
    run(register);
    return () => hookHandles.map((unhook) => unhook());
  }
};
var beforeUrlChange = {
  subscribe: (run) => {
    const hookHandles = [];
    const register = (callback) => {
      const unhook = contexts.router.beforeUrlChange(callback);
      hookHandles.push(unhook);
      return unhook;
    };
    run(register);
    return () => hookHandles.map((unhook) => unhook());
  }
};

// node_modules/@roxi/routify/lib/common/helpers.js
var gentleAssign = (target, ...sources) => {
  sources.forEach(
    (source) => Object.keys(source).forEach((key) => {
      var _a;
      return target[key] = (_a = target[key]) != null ? _a : source[key];
    })
  );
  return target;
};
var assignNode = (target, ...sources) => {
  gentleAssign(target, ...sources);
  gentleAssign(target.meta, ...sources.map((s) => s.meta));
  sources.forEach((source) => {
    source.children.forEach((sNode) => {
      let tNode = target.children.find((tNode2) => tNode2.name === sNode.name);
      if (!tNode)
        tNode = target.createChild(null, null);
      assignNode(tNode, sNode);
    });
  });
  return target;
};
var findNearestParent = (node2, callback) => {
  let parent = node2.parent;
  while (parent) {
    if (callback(parent))
      return parent;
    parent = parent.parent;
  }
};
var getDistance = (parentNode, childNode) => {
  let child = null;
  let distance = 0;
  while (child = childNode.parent) {
    distance++;
    if (parentNode === childNode)
      return distance;
  }
};

// node_modules/@roxi/routify/lib/runtime/index.js
var Routify2 = RoutifyRuntime;
export {
  AddressReflector,
  ComposeFragments_default as Component,
  InternalReflector,
  LocalStorageReflector,
  Router_default as Router,
  Router as RouterClass,
  Routify2 as Routify,
  activeRoute,
  afterUrlChange,
  appInstance,
  assignNode,
  beforeUrlChange,
  context,
  createRouter,
  findNearestParent,
  getDistance,
  getMRCA,
  getPath,
  getScrollBoundaries,
  goto,
  isActive,
  isActiveRoute,
  isActiveUrl,
  meta,
  node,
  params,
  pendingRoute,
  persistentScopedScrollIntoView,
  resolveNode,
  scopedScrollIntoView,
  scrollToContext,
  traverseNode,
  url
};
//# sourceMappingURL=@roxi_routify.js.map
