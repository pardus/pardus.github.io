import {
  buildClientTree,
  currentLocation,
  handleScroll,
  parseUrl,
  resolveUrl,
  runtime_config_default,
  suppressComponentWarnings
} from "./chunk-A3X6NTPK.js";
import {
  derived,
  writable
} from "./chunk-6NUSVQJM.js";
import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_location,
  assign,
  attr_dev,
  check_outros,
  component_subscribe,
  construct_svelte_component_dev,
  create_component,
  create_slot,
  destroy_block,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  get_store_value,
  globals,
  group_outros,
  init,
  insert_dev,
  mount_component,
  noop,
  onDestroy,
  outro_and_destroy_block,
  safe_not_equal,
  setContext,
  set_store_value,
  set_style,
  space,
  src_url_equal,
  tick,
  transition_in,
  transition_out,
  update_keyed_each,
  update_slot_base,
  validate_each_argument,
  validate_each_keys,
  validate_slots,
  validate_store
} from "./chunk-CKECMU6L.js";
import "./chunk-JC4IRQUL.js";

// node_modules/@roxi/routify/runtime/decorators/Noop.svelte
function create_fragment(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes2) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Noop", slots, ["default"]);
  let { scoped = {} } = $$props;
  scoped;
  const writable_props = ["scoped"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Noop> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("scoped" in $$props2)
      $$invalidate(0, scoped = $$props2.scoped);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ scoped });
  $$self.$inject_state = ($$props2) => {
    if ("scoped" in $$props2)
      $$invalidate(0, scoped = $$props2.scoped);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [scoped, $$scope, slots];
}
var Noop = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { scoped: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Noop",
      options,
      id: create_fragment.name
    });
  }
  get scoped() {
    throw new Error("<Noop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scoped(value) {
    throw new Error("<Noop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Noop_default = Noop;

// node_modules/@roxi/routify/runtime/store.js
window.routify = window.routify || {};
var route = writable(null);
var routes = writable([]);
routes.subscribe((routes2) => window.routify.routes = routes2);
var rootContext = writable({ component: { params: {} } });
var urlRoute = writable(null);
var prefetchPath = writable("");
var isChangingPage = writable(true);

// node_modules/@roxi/routify/runtime/utils/onPageLoaded.js
async function onPageLoaded({ page: page2, metatags: metatags2, afterPageLoad: afterPageLoad2, parentNode }) {
  const scrollToTop = page2.last !== page2;
  setTimeout(() => handleScroll(parentNode, scrollToTop));
  const { path } = page2;
  const { options } = currentLocation();
  const prefetchId = options.prefetch;
  for (const hook of afterPageLoad2._hooks) {
    if (hook)
      await hook(page2.api);
  }
  metatags2.update();
  dispatchEvent(new CustomEvent("app-loaded"));
  parent.postMessage({
    msg: "app-loaded",
    prefetched: window.routify.prefetched,
    path,
    prefetchId
  }, "*");
  window["routify"].appLoaded = true;
  window["routify"].stopAutoReady = false;
}

// node_modules/@roxi/routify/runtime/utils/urlToRoute.js
function urlToRoute(url2, clone = false) {
  url2 = runtime_config_default.urlTransform.remove(url2);
  let { pathname, search } = parseUrl(url2).url;
  const routes2 = get_store_value(routes);
  const matchingRoute = (
    // find a route with a matching name
    routes2.find((route3) => pathname === route3.meta.name) || // or a matching path
    routes2.find((route3) => pathname.match(route3.regex))
  );
  if (!matchingRoute)
    throw new Error(`Route could not be found for "${pathname}".`);
  const _matchingRoute = clone ? Object.create(matchingRoute) : matchingRoute;
  const { route: route2, redirectPath, rewritePath } = resolveRedirects(_matchingRoute, routes2);
  if (rewritePath) {
    ({ pathname, search } = parseUrl(resolveUrl(rewritePath, route2.params)).url);
    if (redirectPath)
      route2.redirectTo = resolveUrl(redirectPath, route2.params || {});
  }
  if (runtime_config_default.queryHandler)
    route2.params = Object.assign({}, runtime_config_default.queryHandler.parse(search));
  assignParamsToRouteAndLayouts(route2, pathname);
  route2.leftover = url2.replace(new RegExp(route2.regex), "");
  return route2;
}
function assignParamsToRouteAndLayouts(route2, pathname) {
  if (route2.paramKeys) {
    const layouts = layoutByPos(route2.layouts);
    const fragments = pathname.split("/").filter(Boolean);
    const routeProps = getRouteProps(route2.path);
    routeProps.forEach((prop, i) => {
      if (prop) {
        route2.params[prop] = fragments[i];
        if (layouts[i])
          layouts[i].param = { [prop]: fragments[i] };
        else
          route2.param = { [prop]: fragments[i] };
      }
    });
  }
}
function resolveRedirects(route2, routes2, redirectPath, rewritePath) {
  const { redirect: redirect2, rewrite } = route2.meta;
  if (redirect2 || rewrite) {
    redirectPath = redirect2 ? redirect2.path || redirect2 : redirectPath;
    rewritePath = rewrite ? rewrite.path || rewrite : redirectPath;
    const redirectParams = redirect2 && redirect2.params;
    const rewriteParams = rewrite && rewrite.params;
    const newRoute = routes2.find((r) => r.path.replace(/\/index$/, "") === rewritePath);
    if (newRoute === route2)
      console.error(`${rewritePath} is redirecting to itself`);
    if (!newRoute)
      console.error(`${route2.path} is redirecting to non-existent path: ${rewritePath}`);
    if (redirectParams || rewriteParams)
      newRoute.params = Object.assign({}, newRoute.params, redirectParams, rewriteParams);
    return resolveRedirects(newRoute, routes2, redirectPath, rewritePath);
  }
  return { route: route2, redirectPath, rewritePath };
}
function layoutByPos(layouts) {
  const arr = [];
  layouts.forEach((layout2) => {
    arr[layout2.path.split("/").filter(Boolean).length - 1] = layout2;
  });
  return arr;
}
function getRouteProps(url2) {
  return url2.split("/").filter(Boolean).map((f) => f.match(/\:(.+)/)).map((f) => f && f[1]);
}

// node_modules/@roxi/routify/runtime/Prefetcher.svelte
var file = "node_modules/@roxi/routify/runtime/Prefetcher.svelte";
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[1] = list[i];
  return child_ctx;
}
function create_each_block(key_1, ctx) {
  let iframe;
  let iframe_src_value;
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      iframe = element("iframe");
      if (!src_url_equal(iframe.src, iframe_src_value = /*prefetch*/
      ctx[1].url))
        attr_dev(iframe, "src", iframe_src_value);
      attr_dev(iframe, "frameborder", "0");
      attr_dev(iframe, "title", "routify prefetcher");
      add_location(iframe, file, 80, 4, 2274);
      this.first = iframe;
    },
    m: function mount(target, anchor) {
      insert_dev(target, iframe, anchor);
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*$actives*/
      1 && !src_url_equal(iframe.src, iframe_src_value = /*prefetch*/
      ctx[1].url)) {
        attr_dev(iframe, "src", iframe_src_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(iframe);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(80:2) {#each $actives as prefetch (prefetch.options.prefetch)}",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_value = (
    /*$actives*/
    ctx[0]
  );
  validate_each_argument(each_value);
  const get_key = (ctx2) => (
    /*prefetch*/
    ctx2[1].options.prefetch
  );
  validate_each_keys(ctx, each_value, get_each_context, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
  }
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr_dev(div, "id", "__routify_iframes");
      set_style(div, "display", "none");
      add_location(div, file, 78, 0, 2160);
    },
    l: function claim(nodes2) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*$actives*/
      1) {
        each_value = /*$actives*/
        ctx2[0];
        validate_each_argument(each_value);
        validate_each_keys(ctx2, each_value, get_each_context, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, destroy_block, create_each_block, null, get_each_context);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var iframeNum = 2;
var defaults = {
  validFor: 60,
  timeout: 5e3,
  gracePeriod: 1e3
};
var queue = writable([]);
var actives = derived(queue, (q) => q.slice(0, iframeNum));
actives.subscribe((actives2) => actives2.forEach(({ options }) => {
  setTimeout(() => removeFromQueue(options.prefetch), options.timeout);
}));
function prefetch(path, options = {}) {
  prefetch.id = prefetch.id || 1;
  path = path.href || path;
  options = { ...defaults, ...options };
  options.prefetch = prefetch.id++;
  if (window.routify.prefetched || navigator.userAgent.match("jsdom"))
    return false;
  queue.update((q) => {
    if (!q.some((e) => e.options.path === path))
      q.push({
        url: `${path}__[[routify_url_options]]__${encodeURIComponent(JSON.stringify(options))}`,
        options
      });
    return q;
  });
}
function removeFromQueue(idOrEvent) {
  const id = idOrEvent.data ? idOrEvent.data.prefetchId : idOrEvent;
  if (!id)
    return null;
  const entry = get_store_value(queue).find((entry2) => entry2 && entry2.options.prefetch == id);
  if (entry) {
    const { gracePeriod } = entry.options;
    const gracePromise = new Promise((resolve) => setTimeout(resolve, gracePeriod));
    const idlePromise = new Promise((resolve) => {
      window.requestIdleCallback ? window.requestIdleCallback(resolve) : setTimeout(resolve, gracePeriod + 1e3);
    });
    Promise.all([gracePromise, idlePromise]).then(() => {
      queue.update((q) => q.filter((q2) => q2.options.prefetch != id));
    });
  }
}
addEventListener("message", removeFromQueue, false);
function instance2($$self, $$props, $$invalidate) {
  let $actives;
  validate_store(actives, "actives");
  component_subscribe($$self, actives, ($$value) => $$invalidate(0, $actives = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Prefetcher", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Prefetcher> was created with unknown prop '${key}'`);
  });
  $$self.$capture_state = () => ({
    writable,
    derived,
    get: get_store_value,
    iframeNum,
    defaults,
    queue,
    actives,
    prefetch,
    removeFromQueue,
    $actives
  });
  return [$actives];
}
var Prefetcher = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Prefetcher",
      options,
      id: create_fragment2.name
    });
  }
};
var Prefetcher_default = Prefetcher;

// node_modules/@roxi/routify/runtime/helpers.js
function getRoutifyContext() {
  return getContext("routify") || rootContext;
}
var nodes = {
  subscribe(run) {
    const nodes2 = [];
    return derived(routes, (routes2) => {
      routes2.forEach((route2) => {
        const layouts = route2.layouts.map((layout2) => layout2.api).filter((api) => !nodes2.includes(api));
        nodes2.push(route2.api, ...layouts);
      });
      const find = nodes2.find;
      nodes2.find = (value, ...args) => {
        if (typeof value === "string")
          return nodes2.find((n) => n.meta.name === value) || nodes2.find((n) => n.path === value);
        else
          return find.bind(nodes2)(value, ...args);
      };
      return nodes2;
    }).subscribe(run);
  }
};
var components = nodes;
var page = {
  subscribe(run) {
    return derived(route, (route2) => route2.api).subscribe(run);
  }
};
var node = {
  subscribe(run) {
    const ctx = getRoutifyContext();
    return derived(ctx, (ctx2) => ctx2.component.api).subscribe(run);
  }
};
var layout = {
  subscribe(run) {
    const ctx = getRoutifyContext();
    return derived(ctx, (ctx2) => ctx2.layout.api).subscribe(run);
  }
};
var context = {
  subscribe(run) {
    return getRoutifyContext().subscribe(run);
  }
};
var ready = {
  subscribe(run) {
    window["routify"].stopAutoReady = true;
    async function ready2() {
      await tick();
      await onPageLoaded({ page: get_store_value(route), metatags, afterPageLoad });
    }
    run(ready2);
    return () => {
    };
  }
};
var afterPageLoad = {
  _hooks: [
    (event) => isChangingPage.set(false)
  ],
  subscribe: hookHandler
};
var beforeUrlChange = {
  _hooks: [],
  subscribe: hookHandler
};
function hookHandler(listener) {
  const hooks = this._hooks;
  const index = hooks.length;
  listener((callback) => {
    hooks[index] = callback;
  });
  return (...params2) => {
    delete hooks[index];
    listener(...params2);
  };
}
var params = {
  subscribe(run) {
    const ctx = getRoutifyContext();
    return derived(ctx, (ctx2) => ctx2.route.params).subscribe(run);
  }
};
var leftover = {
  subscribe(listener) {
    return derived(
      route,
      (route2) => route2.leftover
    ).subscribe(listener);
  }
};
function isAncestor(ancestor, descendant, treatIndexAsAncestor = true) {
  ancestor = ancestor.__file || ancestor;
  descendant = descendant.__file || descendant;
  const siblings = descendant.parent === ancestor.parent;
  if (!ancestor.isIndex)
    return false;
  if (descendant.shortPath === ancestor.shortPath)
    return false;
  if (siblings && !descendant.isDir)
    return !!treatIndexAsAncestor;
  return descendant.shortPath.startsWith(ancestor.shortPath);
}
var meta = {
  subscribe(listener) {
    const ctx = getRoutifyContext();
    return derived(ctx, (ctx2) => ctx2.layout.meta).subscribe(listener);
  }
};
var url = {
  subscribe(listener) {
    const ctx = getRoutifyContext();
    return derived(
      ctx,
      (ctx2) => makeUrlHelper(ctx2, ctx2.route, ctx2.routes)
    ).subscribe(
      listener
    );
  }
};
function makeUrlHelper($ctx, $currentRoute, $routes) {
  return function url2(path, params2 = {}, options) {
    const { component } = $ctx;
    const inheritedParams = Object.assign({}, $currentRoute.params, component.params);
    let el = path && path.nodeType && path;
    if (el)
      path = path.getAttribute("href");
    path = path ? resolvePath(path) : component.shortPath;
    const route2 = $routes.find((route3) => [route3.shortPath || "/", route3.path].includes(path));
    if (route2 && route2.meta.preload === "proximity" && window.requestIdleCallback) {
      const delay = routify.appLoaded ? 0 : 1500;
      setTimeout(() => {
        window.requestIdleCallback(() => route2.api.preload());
      }, delay);
    }
    const strict = options && options.strict !== false;
    if (!strict)
      path = path.replace(/index$/, "");
    let url3 = resolveUrl(path, params2, inheritedParams);
    if (el) {
      el.href = url3;
      return {
        update(changedParams) {
          el.href = resolveUrl(path, changedParams, inheritedParams);
        }
      };
    }
    return url3;
    function resolvePath(path2) {
      if (path2.match(/^\.\.?\//)) {
        let [, breadcrumbs, relativePath] = path2.match(/^([\.\/]+)(.*)/);
        let dir = component.path.replace(/\/$/, "");
        const traverse = breadcrumbs.match(/\.\.\//g) || [];
        if (component.isPage)
          traverse.push(null);
        traverse.forEach(() => dir = dir.replace(/\/[^\/]+\/?$/, ""));
        path2 = `${dir}/${relativePath}`.replace(/\/$/, "");
        path2 = path2 || "/";
      } else if (path2.match(/^\//)) {
      } else {
        const matchingRoute = $routes.find((route3) => route3.meta.name === path2);
        if (matchingRoute)
          path2 = matchingRoute.shortPath;
      }
      return path2;
    }
  };
}
var goto = {
  subscribe(listener) {
    const routifyUpdatePage = getContext("routifyupdatepage");
    return derived(
      url,
      (url2) => function goto2(path, params2, _static, shallow) {
        const href = url2(path, params2);
        if (!_static)
          history.pushState({}, null, href);
        else
          routifyUpdatePage(href, shallow);
      }
    ).subscribe(
      listener
    );
  }
};
var redirect = {
  subscribe(listener) {
    const routifyUpdatePage = getContext("routifyupdatepage");
    return derived(
      url,
      (url2) => function redirect2(path, params2, _static, shallow) {
        const href = url2(path, params2);
        if (!_static)
          history.replaceState({}, null, href);
        else
          routifyUpdatePage(href, shallow);
      }
    ).subscribe(
      listener
    );
  }
};
var isActive = {
  subscribe(run) {
    return derived(
      [url, route],
      ([url2, route2]) => function isActive2(path = "", params2 = {}, { strict } = { strict: true }) {
        path = url2(path, params2, { strict });
        const currentPath = url2(route2.path, params2, { strict });
        const re = new RegExp("^" + path + "($|/)");
        return !!currentPath.match(re);
      }
    ).subscribe(run);
  }
};
function precache(path, options) {
  const node2 = typeof path === "string" ? urlToRoute(path) : path;
  node2.component();
}
function prefetch2(path, options) {
  prefetch(path, options);
}
function getConcestor(nodeApi1, nodeApi2) {
  const node1 = nodeApi1.__file;
  const node2 = nodeApi2.__file;
  const lineage1 = [...node1.lineage, node1];
  const lineage2 = [...node2.lineage, node2];
  let concestor = lineage1[0];
  let children = [lineage1[0].api, lineage2[0].api];
  lineage1.forEach((n1, i) => {
    const n2 = lineage2[i];
    if (n2 && n1.parent === n2.parent) {
      concestor = n1.parent;
      children = [n1.api, n2.api];
    }
  });
  return [concestor.api, children[0], children[1]];
}
function getDirection(paths, newPath, oldPath) {
  const newIndex = paths.findIndex((path) => newPath.path.startsWith(path));
  const oldIndex = paths.findIndex((path) => oldPath.path.startsWith(path));
  return newIndex - oldIndex;
}
function focus(element2) {
  if (!focusIsSet) {
    focusIsSet = true;
    element2.setAttribute("tabindex", "0");
    element2.focus();
    setTimeout(() => focusIsSet = false);
  }
}
var focusIsSet = false;
var _metatags = {
  subscribe(listener) {
    this._origin = this.getOrigin();
    return listener(metatags);
  },
  props: {},
  templates: {},
  services: {
    plain: { propField: "name", valueField: "content" },
    twitter: { propField: "name", valueField: "content" },
    og: { propField: "property", valueField: "content" }
  },
  plugins: [
    {
      name: "applyTemplate",
      condition: () => true,
      action: (prop, value) => {
        const template = _metatags.getLongest(_metatags.templates, prop) || ((x) => x);
        return [prop, template(value)];
      }
    },
    {
      name: "createMeta",
      condition: () => true,
      action(prop, value) {
        _metatags.writeMeta(prop, value);
      }
    },
    {
      name: "createOG",
      condition: (prop) => !prop.match(":"),
      action(prop, value) {
        _metatags.writeMeta(`og:${prop}`, value);
      }
    },
    {
      name: "createTitle",
      condition: (prop) => prop === "title",
      action(prop, value) {
        document.title = value;
      }
    }
  ],
  getLongest(repo, name) {
    const providers = repo[name];
    if (providers) {
      const currentPath = get_store_value(route).path;
      const allPaths = Object.keys(repo[name]);
      const matchingPaths = allPaths.filter((path) => currentPath.includes(path));
      const longestKey = matchingPaths.sort((a, b) => b.length - a.length)[0];
      return providers[longestKey];
    }
  },
  writeMeta(prop, value) {
    const head = document.getElementsByTagName("head")[0];
    const match = prop.match(/(.+)\:/);
    const serviceName = match && match[1] || "plain";
    const { propField, valueField } = metatags.services[serviceName] || metatags.services.plain;
    const oldElement = document.querySelector(`meta[${propField}='${prop}']`);
    if (oldElement)
      oldElement.remove();
    const newElement = document.createElement("meta");
    newElement.setAttribute(propField, prop);
    newElement.setAttribute(valueField, value);
    newElement.setAttribute("data-origin", "routify");
    head.appendChild(newElement);
  },
  set(prop, value) {
    if (typeof prop === "string") {
      _metatags.plugins.forEach((plugin) => {
        if (plugin.condition(prop, value))
          [prop, value] = plugin.action(prop, value) || [prop, value];
      });
    }
  },
  clear() {
    const oldElement = document.querySelector(`meta`);
    if (oldElement)
      oldElement.remove();
  },
  template(name, fn) {
    const origin = _metatags.getOrigin;
    _metatags.templates[name] = _metatags.templates[name] || {};
    _metatags.templates[name][origin] = fn;
  },
  update() {
    Object.keys(_metatags.props).forEach((prop) => {
      let value = _metatags.getLongest(_metatags.props, prop);
      _metatags.plugins.forEach((plugin) => {
        if (plugin.condition(prop, value)) {
          [prop, value] = plugin.action(prop, value) || [prop, value];
        }
      });
    });
  },
  batchedUpdate() {
    if (!_metatags._pendingUpdate) {
      _metatags._pendingUpdate = true;
      setTimeout(() => {
        _metatags._pendingUpdate = false;
        this.update();
      });
    }
  },
  _updateQueued: false,
  _origin: false,
  getOrigin() {
    if (this._origin)
      return this._origin;
    const routifyCtx = getRoutifyContext();
    return routifyCtx && get_store_value(routifyCtx).path || "/";
  },
  _pendingUpdate: false
};
var metatags = new Proxy(_metatags, {
  set(target, name, value, receiver) {
    const { props } = target;
    if (Reflect.has(target, name))
      Reflect.set(target, name, value, receiver);
    else {
      props[name] = props[name] || {};
      props[name][target.getOrigin()] = value;
    }
    if (window["routify"].appLoaded)
      target.batchedUpdate();
    return true;
  }
});

// node_modules/@roxi/routify/runtime/Route.svelte
var file2 = "node_modules/@roxi/routify/runtime/Route.svelte";
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[21] = list[i].component;
  child_ctx[22] = list[i].componentFile;
  child_ctx[2] = list[i].decorator;
  child_ctx[1] = list[i].nodes;
  return child_ctx;
}
function create_if_block_1(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = [
    /*$context*/
    ctx[4]
  ];
  validate_each_argument(each_value);
  const get_key = (ctx2) => (
    /*id*/
    ctx2[7]
  );
  validate_each_keys(ctx, each_value, get_each_context2, get_key);
  for (let i = 0; i < 1; i += 1) {
    let child_ctx = get_each_context2(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block2(key, child_ctx));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < 1; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < 1; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$context, scoped, scopedSync, node, decorator, scopeToChild, id*/
      33554621) {
        each_value = [
          /*$context*/
          ctx2[4]
        ];
        validate_each_argument(each_value);
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context2, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block2, each_1_anchor, get_each_context2);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < 1; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < 1; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      for (let i = 0; i < 1; i += 1) {
        each_blocks[i].d(detaching);
      }
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(109:0) {#if $context}",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let route_1;
  let current;
  route_1 = new Route({
    props: {
      decorator: (
        /*decorator*/
        ctx[2]
      ),
      nodes: (
        /*nodes*/
        ctx[1]
      ),
      scoped: {
        .../*scoped*/
        ctx[0],
        .../*scopeToChild*/
        ctx[25]
      }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(route_1.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(route_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const route_1_changes = {};
      if (dirty & /*decorator*/
      4)
        route_1_changes.decorator = /*decorator*/
        ctx2[2];
      if (dirty & /*$context*/
      16)
        route_1_changes.nodes = /*nodes*/
        ctx2[1];
      if (dirty & /*scoped, scopeToChild*/
      33554433)
        route_1_changes.scoped = {
          .../*scoped*/
          ctx2[0],
          .../*scopeToChild*/
          ctx2[25]
        };
      route_1.$set(route_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(route_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(route_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(route_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(120:8) {#if component && nodes.length}",
    ctx
  });
  return block;
}
function create_default_slot_1(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*component*/
    ctx[21] && /*nodes*/
    ctx[1].length && create_if_block_2(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*component*/
        ctx2[21] && /*nodes*/
        ctx2[1].length
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$context*/
          16) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: "(112:6) <svelte:component         this={componentFile}         let:scoped={scopeToChild}         let:decorator         {scoped}         {scopedSync}         {...node.param || {}}       >",
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let switch_instance;
  let t;
  let current;
  const switch_instance_spread_levels = [
    { scoped: (
      /*scoped*/
      ctx[0]
    ) },
    { scopedSync: (
      /*scopedSync*/
      ctx[5]
    ) },
    /*node*/
    ctx[3].param || {}
  ];
  var switch_value = (
    /*componentFile*/
    ctx[22]
  );
  function switch_props(ctx2) {
    let switch_instance_props = {
      $$slots: {
        default: [
          create_default_slot_1,
          ({ scoped: scopeToChild, decorator }) => ({ 25: scopeToChild, 2: decorator }),
          ({ scoped: scopeToChild, decorator }) => (scopeToChild ? 33554432 : 0) | (decorator ? 4 : 0)
        ]
      },
      $$scope: { ctx: ctx2 }
    };
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      t = space();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_dev(target, t, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const switch_instance_changes = dirty & /*scoped, scopedSync, node*/
      41 ? get_spread_update(switch_instance_spread_levels, [
        dirty & /*scoped*/
        1 && { scoped: (
          /*scoped*/
          ctx2[0]
        ) },
        dirty & /*scopedSync*/
        32 && { scopedSync: (
          /*scopedSync*/
          ctx2[5]
        ) },
        dirty & /*node*/
        8 && get_spread_object(
          /*node*/
          ctx2[3].param || {}
        )
      ]) : {};
      if (dirty & /*$$scope, decorator, $context, scoped, scopeToChild*/
      100663317) {
        switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (dirty & /*$context*/
      16 && switch_value !== (switch_value = /*componentFile*/
      ctx2[22])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, t.parentNode, t);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (switch_instance)
        destroy_component(switch_instance, detaching);
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(111:4) <svelte:component this={decorator} {scoped}>",
    ctx
  });
  return block;
}
function create_each_block2(key_1, ctx) {
  let first;
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*decorator*/
    ctx[2]
  );
  function switch_props(ctx2) {
    return {
      props: {
        scoped: (
          /*scoped*/
          ctx2[0]
        ),
        $$slots: { default: [create_default_slot] },
        $$scope: { ctx: ctx2 }
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_dev(target, first, anchor);
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const switch_instance_changes = {};
      if (dirty & /*scoped*/
      1)
        switch_instance_changes.scoped = /*scoped*/
        ctx[0];
      if (dirty & /*$$scope, $context, scoped, scopedSync, node, decorator*/
      67108925) {
        switch_instance_changes.$$scope = { dirty, ctx };
      }
      if (dirty & /*$context*/
      16 && switch_value !== (switch_value = /*decorator*/
      ctx[2])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(first);
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block2.name,
    type: "each",
    source: "(110:2) {#each [$context] as { component, componentFile, decorator, nodes }",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let div;
  let setParentNode_action;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      set_style(div, "display", "contents");
      add_location(div, file2, 133, 2, 4156);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (!mounted) {
        dispose = action_destroyer(setParentNode_action = /*setParentNode*/
        ctx[10].call(null, div));
        mounted = true;
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(133:0) {#if !parentNode}",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let t;
  let if_block1_anchor;
  let current;
  let if_block0 = (
    /*$context*/
    ctx[4] && create_if_block_1(ctx)
  );
  let if_block1 = !/*parentNode*/
  ctx[6] && create_if_block(ctx);
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    l: function claim(nodes2) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_dev(target, t, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_dev(target, if_block1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$context*/
        ctx2[4]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$context*/
          16) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t.parentNode, t);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!/*parentNode*/
      ctx2[6]) {
        if (if_block1) {
        } else {
          if_block1 = create_if_block(ctx2);
          if_block1.c();
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(if_block1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let id;
  let $context;
  let $route;
  let $parentContext;
  let $routes;
  validate_store(route, "route");
  component_subscribe($$self, route, ($$value) => $$invalidate(14, $route = $$value));
  validate_store(routes, "routes");
  component_subscribe($$self, routes, ($$value) => $$invalidate(16, $routes = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Route", slots, []);
  let { nodes: nodes2 = [] } = $$props;
  let { scoped = {} } = $$props;
  let { decorator = void 0 } = $$props;
  let node2 = null;
  let remainingNodes = null;
  let scopedSync = {};
  let parentNode;
  let invalidate = 1;
  const context2 = writable(null);
  validate_store(context2, "context");
  component_subscribe($$self, context2, (value) => $$invalidate(4, $context = value));
  const parentContext = getContext("routify") || rootContext;
  validate_store(parentContext, "parentContext");
  component_subscribe($$self, parentContext, (value) => $$invalidate(15, $parentContext = value));
  const setParentNode = (el) => $$invalidate(6, parentNode = el.parentNode);
  setContext("routify", context2);
  let lastNodes = [];
  function setComponent(node3) {
    let PendingComponent = node3.component();
    if (PendingComponent instanceof Promise)
      PendingComponent.then(onComponentLoaded);
    else
      onComponentLoaded(PendingComponent);
  }
  function onComponentLoaded(componentFile) {
    $$invalidate(5, scopedSync = { ...scoped });
    const ctx = {
      //we need to keep any possible context.child or the layout will be childless until the new child has been rendered
      ...$context,
      nodes: remainingNodes,
      decorator: decorator || Noop_default,
      layout: node2.isLayout ? node2 : $parentContext.layout,
      component: node2,
      route: $route,
      routes: $routes,
      componentFile,
      parentNode: parentNode || $parentContext.parentNode
    };
    context2.set(ctx);
    set_store_value(parentContext, $parentContext.child = node2, $parentContext);
    if (remainingNodes.length === 0)
      onLastComponentLoaded();
  }
  async function onLastComponentLoaded() {
    await new Promise((resolve) => setTimeout(resolve));
    const isOnCurrentRoute = $context.component.path === $route.path;
    if (!window["routify"].stopAutoReady && isOnCurrentRoute)
      onPageLoaded({
        page: $context.component,
        metatags,
        afterPageLoad,
        parentNode
      });
  }
  function getID({ meta: meta2, path, param, params: params2 }) {
    return JSON.stringify({
      path,
      invalidate,
      param: (meta2["param-is-page"] || meta2["slug-is-page"]) && param,
      queryParams: meta2["query-params-is-page"] && params2
    });
  }
  const writable_props = ["nodes", "scoped", "decorator"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Route> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("nodes" in $$props2)
      $$invalidate(1, nodes2 = $$props2.nodes);
    if ("scoped" in $$props2)
      $$invalidate(0, scoped = $$props2.scoped);
    if ("decorator" in $$props2)
      $$invalidate(2, decorator = $$props2.decorator);
  };
  $$self.$capture_state = () => ({
    suppressComponentWarnings,
    Noop: Noop_default,
    getContext,
    setContext,
    tick,
    writable,
    metatags,
    afterPageLoad,
    route,
    routes,
    rootContext,
    handleScroll,
    onPageLoaded,
    nodes: nodes2,
    scoped,
    decorator,
    node: node2,
    remainingNodes,
    scopedSync,
    parentNode,
    invalidate,
    context: context2,
    parentContext,
    setParentNode,
    lastNodes,
    setComponent,
    onComponentLoaded,
    onLastComponentLoaded,
    getID,
    id,
    $context,
    $route,
    $parentContext,
    $routes
  });
  $$self.$inject_state = ($$props2) => {
    if ("nodes" in $$props2)
      $$invalidate(1, nodes2 = $$props2.nodes);
    if ("scoped" in $$props2)
      $$invalidate(0, scoped = $$props2.scoped);
    if ("decorator" in $$props2)
      $$invalidate(2, decorator = $$props2.decorator);
    if ("node" in $$props2)
      $$invalidate(3, node2 = $$props2.node);
    if ("remainingNodes" in $$props2)
      remainingNodes = $$props2.remainingNodes;
    if ("scopedSync" in $$props2)
      $$invalidate(5, scopedSync = $$props2.scopedSync);
    if ("parentNode" in $$props2)
      $$invalidate(6, parentNode = $$props2.parentNode);
    if ("invalidate" in $$props2)
      $$invalidate(11, invalidate = $$props2.invalidate);
    if ("lastNodes" in $$props2)
      $$invalidate(12, lastNodes = $$props2.lastNodes);
    if ("id" in $$props2)
      $$invalidate(7, id = $$props2.id);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*lastNodes, nodes, invalidate*/
    6146) {
      $:
        if (lastNodes !== nodes2) {
          $$invalidate(12, lastNodes = nodes2);
          $$invalidate(3, [node2, ...remainingNodes] = [...nodes2], node2);
          $$invalidate(3, node2["api"].reset = () => $$invalidate(11, invalidate++, invalidate), node2);
        }
    }
    if ($$self.$$.dirty & /*node*/
    8) {
      $:
        setComponent(node2);
    }
    if ($$self.$$.dirty & /*$context, invalidate*/
    2064) {
      $:
        $$invalidate(7, id = $context && invalidate && getID($context.component));
    }
    if ($$self.$$.dirty & /*$context*/
    16) {
      $:
        $context && suppressComponentWarnings($context, tick);
    }
  };
  return [
    scoped,
    nodes2,
    decorator,
    node2,
    $context,
    scopedSync,
    parentNode,
    id,
    context2,
    parentContext,
    setParentNode,
    invalidate,
    lastNodes
  ];
}
var Route = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { nodes: 1, scoped: 0, decorator: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Route",
      options,
      id: create_fragment3.name
    });
  }
  get nodes() {
    throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodes(value) {
    throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scoped() {
    throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scoped(value) {
    throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get decorator() {
    throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set decorator(value) {
    throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Route_default = Route;

// node_modules/@roxi/routify/runtime/navigator.js
function init2(routes2, callback) {
  let lastRoute = false;
  function updatePage(proxyToUrl, shallow) {
    const url2 = proxyToUrl || currentLocation().fullpath;
    const route2 = urlToRoute(url2);
    if (route2.redirectTo) {
      history.replaceStateNative({}, null, route2.redirectTo);
      delete route2.redirectTo;
    }
    const currentRoute = shallow && urlToRoute(currentLocation().fullpath, routes2);
    const contextRoute = currentRoute || route2;
    const nodes2 = [...contextRoute.layouts, route2];
    if (lastRoute)
      delete lastRoute.last;
    route2.last = lastRoute;
    lastRoute = route2;
    if (!proxyToUrl)
      urlRoute.set(route2);
    route.set(route2);
    route2.api.preload().then(() => {
      isChangingPage.set(true);
      callback(nodes2);
    });
  }
  const destroy = createEventListeners(updatePage);
  return { updatePage, destroy };
}
function createEventListeners(updatePage) {
  ;
  ["pushState", "replaceState"].forEach((eventName) => {
    if (!history[eventName + "Native"])
      history[eventName + "Native"] = history[eventName];
    history[eventName] = async function(state = {}, title, url2) {
      const currentUrl = location.pathname + location.search + location.hash;
      if (url2 === currentUrl)
        return false;
      const { id, path, params: params2 } = get_store_value(route);
      state = { id, path, params: params2, ...state };
      const event = new Event(eventName.toLowerCase());
      Object.assign(event, { state, title, url: url2 });
      const route2 = await runHooksBeforeUrlChange(event, url2);
      if (route2) {
        history[eventName + "Native"].apply(this, [state, title, url2]);
        return dispatchEvent(event);
      }
    };
  });
  let _ignoreNextPop = false;
  const listeners = {
    click: handleClick,
    pushstate: () => updatePage(),
    replacestate: () => updatePage(),
    popstate: async (event) => {
      if (_ignoreNextPop)
        _ignoreNextPop = false;
      else {
        if (await runHooksBeforeUrlChange(event, currentLocation().fullpath)) {
          updatePage();
        } else {
          _ignoreNextPop = true;
          event.preventDefault();
          history.go(1);
        }
      }
    }
  };
  Object.entries(listeners).forEach((args) => addEventListener(...args));
  const unregister = () => {
    Object.entries(listeners).forEach((args) => removeEventListener(...args));
  };
  return unregister;
}
function handleClick(event) {
  const el = event.target.closest("a") || event.composedPath().find((el2) => el2.tagName === "A");
  const href = el && el.href;
  if (event.ctrlKey || event.metaKey || event.altKey || event.shiftKey || event.button || event.defaultPrevented)
    return;
  if (!href || el.target || el.host !== location.host)
    return;
  const url2 = new URL(href);
  const relativeUrl = url2.pathname + url2.search + url2.hash;
  event.preventDefault();
  history.pushState({}, "", relativeUrl);
}
async function runHooksBeforeUrlChange(event, url2) {
  const route2 = urlToRoute(url2).api;
  for (const hook of beforeUrlChange._hooks.filter(Boolean)) {
    const result = await hook(event, route2, { url: url2 });
    if (!result)
      return false;
  }
  return true;
}

// node_modules/@roxi/routify/runtime/Router.svelte
var { Object: Object_1 } = globals;
function create_if_block2(ctx) {
  let route_1;
  let current;
  route_1 = new Route_default({
    props: { nodes: (
      /*nodes*/
      ctx[0]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(route_1.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(route_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const route_1_changes = {};
      if (dirty & /*nodes*/
      1)
        route_1_changes.nodes = /*nodes*/
        ctx2[0];
      route_1.$set(route_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(route_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(route_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(route_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(58:0) {#if nodes && $route !== null}",
    ctx
  });
  return block;
}
function create_fragment4(ctx) {
  let t;
  let prefetcher;
  let current;
  let if_block = (
    /*nodes*/
    ctx[0] && /*$route*/
    ctx[1] !== null && create_if_block2(ctx)
  );
  prefetcher = new Prefetcher_default({ $$inline: true });
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      t = space();
      create_component(prefetcher.$$.fragment);
    },
    l: function claim(nodes2) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, t, anchor);
      mount_component(prefetcher, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*nodes*/
        ctx2[0] && /*$route*/
        ctx2[1] !== null
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*nodes, $route*/
          3) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(prefetcher.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(prefetcher.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(t);
      destroy_component(prefetcher, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let $route;
  validate_store(route, "route");
  component_subscribe($$self, route, ($$value) => $$invalidate(1, $route = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Router", slots, []);
  let { routes: routes2 } = $$props;
  let { config = {} } = $$props;
  let nodes2;
  let navigator2;
  window.routify = window.routify || {};
  window.routify.inBrowser = !window.navigator.userAgent.match("jsdom");
  Object.assign(runtime_config_default, config);
  const updatePage = (...args) => navigator2 && navigator2.updatePage(...args);
  setContext("routifyupdatepage", updatePage);
  const callback = (res) => $$invalidate(0, nodes2 = res);
  const cleanup = () => {
    if (!navigator2)
      return;
    navigator2.destroy();
    navigator2 = null;
  };
  let initTimeout = null;
  const doInit = () => {
    clearTimeout(initTimeout);
    initTimeout = setTimeout(() => {
      cleanup();
      navigator2 = init2(routes2, callback);
      routes.set(routes2);
      navigator2.updatePage();
    });
  };
  onDestroy(cleanup);
  $$self.$$.on_mount.push(function() {
    if (routes2 === void 0 && !("routes" in $$props || $$self.$$.bound[$$self.$$.props["routes"]])) {
      console.warn("<Router> was created without expected prop 'routes'");
    }
  });
  const writable_props = ["routes", "config"];
  Object_1.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Router> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("routes" in $$props2)
      $$invalidate(2, routes2 = $$props2.routes);
    if ("config" in $$props2)
      $$invalidate(3, config = $$props2.config);
  };
  $$self.$capture_state = () => ({
    setContext,
    onDestroy,
    Route: Route_default,
    Prefetcher: Prefetcher_default,
    init: init2,
    route,
    routesStore: routes,
    defaultConfig: runtime_config_default,
    routes: routes2,
    config,
    nodes: nodes2,
    navigator: navigator2,
    updatePage,
    callback,
    cleanup,
    initTimeout,
    doInit,
    $route
  });
  $$self.$inject_state = ($$props2) => {
    if ("routes" in $$props2)
      $$invalidate(2, routes2 = $$props2.routes);
    if ("config" in $$props2)
      $$invalidate(3, config = $$props2.config);
    if ("nodes" in $$props2)
      $$invalidate(0, nodes2 = $$props2.nodes);
    if ("navigator" in $$props2)
      navigator2 = $$props2.navigator;
    if ("initTimeout" in $$props2)
      initTimeout = $$props2.initTimeout;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*routes*/
    4) {
      $:
        if (routes2)
          doInit();
    }
  };
  return [nodes2, $route, routes2, config];
}
var Router = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, { routes: 2, config: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Router",
      options,
      id: create_fragment4.name
    });
  }
  get routes() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set routes(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get config() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set config(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Router_default = Router;
export {
  Route_default as Route,
  Router_default as Router,
  afterPageLoad,
  beforeUrlChange,
  buildClientTree,
  components,
  context,
  focus,
  getConcestor,
  getDirection,
  goto,
  isActive,
  isAncestor,
  isChangingPage,
  layout,
  leftover,
  makeUrlHelper,
  meta,
  metatags,
  node,
  nodes,
  page,
  params,
  precache,
  prefetch2 as prefetch,
  prefetchPath,
  ready,
  redirect,
  rootContext,
  route,
  routes,
  url,
  urlRoute
};
//# sourceMappingURL=@roxi_routify.js.map
